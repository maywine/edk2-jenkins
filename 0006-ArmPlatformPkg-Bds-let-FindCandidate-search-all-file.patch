From 684b90bb09eb57cb21956746e6ea86bce87849e8 Mon Sep 17 00:00:00 2001
From: Laszlo Ersek <lersek@redhat.com>
Date: Thu, 13 Nov 2014 15:18:41 +0100
Subject: [PATCH 6/9] ArmPlatformPkg/Bds: let FindCandidate() search all
 filesystems

Thus far FindCandidate() has looked only at the EFI System Partition that
was found first. Let's scan all handles with the ESP protocol instead, and
if we still can't find a boot option candidate, go through all FAT
filesystems as well. (The latter set will probably include the former set,
but that's no problem.)

This is motivated by the fact that PartitionDxe doesn't install the ESP
protocol for ElTorito (ie. CD-ROM) boot images, therefore FindCandidate()
was unable to find any candidates on CD-ROMs.

Contributed-under: TianoCore Contribution Agreement 1.0
Signed-off-by: Laszlo Ersek <lersek@redhat.com>
---
 ArmPlatformPkg/Bds/Bds.c | 51 ++++++++++++++++++++++++++++++++++++------------
 1 file changed, 39 insertions(+), 12 deletions(-)

diff --git a/ArmPlatformPkg/Bds/Bds.c b/ArmPlatformPkg/Bds/Bds.c
index a0ca7c4..6f70483 100644
--- a/ArmPlatformPkg/Bds/Bds.c
+++ b/ArmPlatformPkg/Bds/Bds.c
@@ -214,7 +214,7 @@ InitializeConsole (
 
 STATIC
 EFI_STATUS
-FindCandidate (
+FindCandidateOnHandle (
   IN  EFI_HANDLE       Handle,
   OUT EFI_DEVICE_PATH  **Candidate
   )
@@ -269,6 +269,43 @@ CloseRoot:
   return Status;
 }
 
+
+STATIC
+EFI_STATUS
+FindCandidate (
+  OUT EFI_DEVICE_PATH  **Candidate
+  )
+{
+  EFI_STATUS              Status;
+  EFI_GUID * CONST        *FilterGuid;
+  STATIC EFI_GUID * CONST FilterGuids[] = { &gEfiPartTypeSystemPartGuid,
+                            &gEfiSimpleFileSystemProtocolGuid, NULL };
+
+  Status = EFI_NOT_FOUND;
+  FilterGuid = FilterGuids;
+  while (EFI_ERROR (Status) && *FilterGuid != NULL) {
+    UINTN      NrHandles;
+    EFI_HANDLE *Handles;
+
+    Status = gBS->LocateHandleBuffer (ByProtocol, *FilterGuid,
+                    NULL /* SearchKey */, &NrHandles, &Handles);
+    if (!EFI_ERROR (Status)) {
+      UINTN Idx;
+
+      Status = EFI_NOT_FOUND;
+      Idx = 0;
+      while (EFI_ERROR (Status) && Idx < NrHandles) {
+        Status = FindCandidateOnHandle (Handles[Idx], Candidate);
+        ++Idx;
+      }
+      FreePool (Handles);
+    }
+    ++FilterGuid;
+  }
+  return Status;
+}
+
+
 EFI_STATUS
 DefineDefaultBootEntries (
   VOID
@@ -297,18 +334,8 @@ DefineDefaultBootEntries (
   Status = gRT->GetVariable (L"BootOrder", &gEfiGlobalVariableGuid, NULL, &Size, NULL);
   if (Status == EFI_NOT_FOUND) {
     if ((PcdGetPtr(PcdDefaultBootDevicePath) == NULL) || (StrLen ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath)) == 0)) {
-      UINTN      NrHandles;
-      EFI_HANDLE *Handles;
-
       BdsConnectAllDrivers();
-      Status = gBS->LocateHandleBuffer (ByProtocol,
-                      &gEfiPartTypeSystemPartGuid, NULL /* SearchKey */,
-                      &NrHandles, &Handles);
-      if (!EFI_ERROR (Status)) {
-        ASSERT (NrHandles > 0);
-        Status = FindCandidate (Handles[0], &BootDevicePath);
-        FreePool (Handles);
-      }
+      Status = FindCandidate (&BootDevicePath);
       if (EFI_ERROR (Status)) {
         DEBUG ((EFI_D_ERROR, "failed to auto-create default boot option: %r\n",
           Status));
-- 
1.8.3.1

