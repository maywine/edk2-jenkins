diff --git a/README.md b/README.md
new file mode 100644
index 0000000..c62b893
--- /dev/null
+++ b/README.md
@@ -0,0 +1,39 @@
+Tianocore as coreboot payload
+=============================
+
+This branch introduces the corebootPkg. It allows to easily build a tianocore image
+that is suitable as coreboot payload.
+
+After setting up your EDK2 environment (BaseTools/gcc/mingw-gcc-build.py can help you
+with the cross compiler), and entering the environment (". edksetup.sh"), build
+corebootPkg using one of
+
+  build -a IA32 -p corebootPkg/corebootPkg.dsc
+  build -a X64 -p corebootPkg/corebootPkg.dsc
+
+This ideally creates Build/coreboot{IA32,X64}/DEBUG_UNIXGCC/FV/COREBOOT.fd, the payload image.
+
+Configure coreboot to use a Tianocore payload and point it to the COREBOOT.fd
+created before.
+
+Build, run, have fun.
+
+CSM Support
+-----------
+It's possible to run corebootPkg with SeaBIOS as CSM. David Woodhouse did the necessary work
+at http://git.infradead.org/users/dwmw2/edk2.git which I integrated (Thanks David!).
+
+1. Fetch SeaBIOS master (eg. git clone http://review.coreboot.org/seabios.git).
+2. Apply http://git.infradead.org/users/dwmw2/seabios.git/commitdiff/ef6babf96de2b2a15318ee113aee38f5e882e50a to SeaBIOS
+3. Build SeaBIOS as CSM (General Features - Build Target - Build as Compatibility Support Module ...)
+4. Copy $SEABIOS/out/bios.bin to $TIANO/corebootPkg/Csm/Csm16/Csm16.bin
+5. Add -D CSM_ENABLE=TRUE to the tiano build line above
+
+From here, proceed as usual (add COREBOOT.fd as payload).
+
+Please note that the vgabios-cirrus.bin shipped with QEmu/KVM isn't exactly in the format CSM expects.
+See https://lists.gnu.org/archive/html/qemu-devel/2013-01/msg03650.html
+
+Using SeaBIOS' vgabios implementation for QEmu from latest master should work.
+
+-- Patrick Georgi
diff --git a/corebootPkg/AcpiPlatformDxe/AcpiPlatform.c b/corebootPkg/AcpiPlatformDxe/AcpiPlatform.c
new file mode 100644
index 0000000..5fa11ba
--- /dev/null
+++ b/corebootPkg/AcpiPlatformDxe/AcpiPlatform.c
@@ -0,0 +1,264 @@
+/** @file
+  OVMF ACPI Platform Driver
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "AcpiPlatform.h"
+
+EFI_STATUS
+EFIAPI
+InstallAcpiTable (
+  IN   EFI_ACPI_TABLE_PROTOCOL       *AcpiProtocol,
+  IN   VOID                          *AcpiTableBuffer,
+  IN   UINTN                         AcpiTableBufferSize,
+  OUT  UINTN                         *TableKey
+  )
+{
+  return AcpiProtocol->InstallAcpiTable (
+                         AcpiProtocol,
+                         AcpiTableBuffer,
+                         AcpiTableBufferSize,
+                         TableKey
+                         );
+}
+
+
+/**
+  Locate the first instance of a protocol.  If the protocol requested is an
+  FV protocol, then it will return the first FV that contains the ACPI table
+  storage file.
+
+  @param  Instance      Return pointer to the first instance of the protocol
+
+  @return EFI_SUCCESS           The function completed successfully.
+  @return EFI_NOT_FOUND         The protocol could not be located.
+  @return EFI_OUT_OF_RESOURCES  There are not enough resources to find the protocol.
+
+**/
+EFI_STATUS
+LocateFvInstanceWithTables (
+  OUT EFI_FIRMWARE_VOLUME2_PROTOCOL **Instance
+  )
+{
+  EFI_STATUS                    Status;
+  EFI_HANDLE                    *HandleBuffer;
+  UINTN                         NumberOfHandles;
+  EFI_FV_FILETYPE               FileType;
+  UINT32                        FvStatus;
+  EFI_FV_FILE_ATTRIBUTES        Attributes;
+  UINTN                         Size;
+  UINTN                         Index;
+  EFI_FIRMWARE_VOLUME2_PROTOCOL *FvInstance;
+
+  FvStatus = 0;
+
+  //
+  // Locate protocol.
+  //
+  Status = gBS->LocateHandleBuffer (
+                   ByProtocol,
+                   &gEfiFirmwareVolume2ProtocolGuid,
+                   NULL,
+                   &NumberOfHandles,
+                   &HandleBuffer
+                   );
+  if (EFI_ERROR (Status)) {
+    //
+    // Defined errors at this time are not found and out of resources.
+    //
+    return Status;
+  }
+
+  //
+  // Looking for FV with ACPI storage file
+  //
+  for (Index = 0; Index < NumberOfHandles; Index++) {
+    //
+    // Get the protocol on this handle
+    // This should not fail because of LocateHandleBuffer
+    //
+    Status = gBS->HandleProtocol (
+                     HandleBuffer[Index],
+                     &gEfiFirmwareVolume2ProtocolGuid,
+                     (VOID**) &FvInstance
+                     );
+    ASSERT_EFI_ERROR (Status);
+
+    //
+    // See if it has the ACPI storage file
+    //
+    Status = FvInstance->ReadFile (
+                           FvInstance,
+                           (EFI_GUID*)PcdGetPtr (PcdAcpiTableStorageFile),
+                           NULL,
+                           &Size,
+                           &FileType,
+                           &Attributes,
+                           &FvStatus
+                           );
+
+    //
+    // If we found it, then we are done
+    //
+    if (Status == EFI_SUCCESS) {
+      *Instance = FvInstance;
+      break;
+    }
+  }
+
+  //
+  // Our exit status is determined by the success of the previous operations
+  // If the protocol was found, Instance already points to it.
+  //
+
+  //
+  // Free any allocated buffers
+  //
+  gBS->FreePool (HandleBuffer);
+
+  return Status;
+}
+
+
+/**
+  Find ACPI tables in an FV and parses them. This function is useful for QEMU and KVM.
+
+  @param  AcpiTable     Protocol instance pointer    
+
+**/
+EFI_STATUS
+EFIAPI
+FindAcpiTablesInFv (
+  IN  EFI_ACPI_TABLE_PROTOCOL     *AcpiTable
+  )
+{
+  EFI_STATUS                           Status;
+  EFI_FIRMWARE_VOLUME2_PROTOCOL        *FwVol;
+  INTN                                 Instance;
+  EFI_ACPI_COMMON_HEADER               *CurrentTable;
+  UINTN                                TableHandle;
+  UINT32                               FvStatus;
+  UINTN                                TableSize;
+  UINTN                                Size;
+  EFI_ACPI_TABLE_INSTALL_ACPI_TABLE    TableInstallFunction;
+
+  Instance     = 0;
+  CurrentTable = NULL;
+  TableHandle  = 0;
+
+  if (QemuDetected ()) {
+    TableInstallFunction = QemuInstallAcpiTable;
+  } else {
+    TableInstallFunction = InstallAcpiTable;
+  }
+
+  //
+  // Locate the firmware volume protocol
+  //
+  Status = LocateFvInstanceWithTables (&FwVol);
+  if (EFI_ERROR (Status)) {
+    return EFI_ABORTED;
+  }
+  //
+  // Read tables from the storage file.
+  //
+  while (Status == EFI_SUCCESS) {
+
+    Status = FwVol->ReadSection (
+                      FwVol,
+                      (EFI_GUID*)PcdGetPtr (PcdAcpiTableStorageFile),
+                      EFI_SECTION_RAW,
+                      Instance,
+                      (VOID**) &CurrentTable,
+                      &Size,
+                      &FvStatus
+                      );
+    if (!EFI_ERROR (Status)) {
+      //
+      // Add the table
+      //
+      TableHandle = 0;
+
+      TableSize = ((EFI_ACPI_DESCRIPTION_HEADER *) CurrentTable)->Length;
+      ASSERT (Size >= TableSize);
+
+      //
+      // Install ACPI table
+      //
+      Status = TableInstallFunction (
+                 AcpiTable,
+                 CurrentTable,
+                 TableSize,
+                 &TableHandle
+                 );
+
+      //
+      // Free memory allocated by ReadSection
+      //
+      gBS->FreePool (CurrentTable);
+
+      if (EFI_ERROR (Status)) {
+        return EFI_ABORTED;
+      }
+
+      //
+      // Increment the instance
+      //
+      Instance++;
+      CurrentTable = NULL;
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Entrypoint of Acpi Platform driver.
+
+  @param  ImageHandle
+  @param  SystemTable
+
+  @return EFI_SUCCESS
+  @return EFI_LOAD_ERROR
+  @return EFI_OUT_OF_RESOURCES
+
+**/
+EFI_STATUS
+EFIAPI
+AcpiPlatformEntryPoint (
+  IN EFI_HANDLE         ImageHandle,
+  IN EFI_SYSTEM_TABLE   *SystemTable
+  )
+{
+  EFI_STATUS                         Status;
+  EFI_ACPI_TABLE_PROTOCOL            *AcpiTable;
+
+  //
+  // Find the AcpiTable protocol
+  //
+  Status = gBS->LocateProtocol (
+                  &gEfiAcpiTableProtocolGuid,
+                  NULL,
+                  (VOID**)&AcpiTable
+                  );
+  if (EFI_ERROR (Status)) {
+    return EFI_ABORTED;
+  }
+
+  Status = FindAcpiTablesInFv (AcpiTable);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
diff --git a/corebootPkg/AcpiPlatformDxe/AcpiPlatform.h b/corebootPkg/AcpiPlatformDxe/AcpiPlatform.h
new file mode 100644
index 0000000..4cb0727
--- /dev/null
+++ b/corebootPkg/AcpiPlatformDxe/AcpiPlatform.h
@@ -0,0 +1,54 @@
+/** @file
+  Sample ACPI Platform Driver
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/ 
+
+#ifndef _ACPI_PLATFORM_H_INCLUDED_
+#define _ACPI_PLATFORM_H_INCLUDED_
+
+#include <PiDxe.h>
+
+#include <Protocol/AcpiTable.h>
+#include <Protocol/FirmwareVolume2.h>
+
+#include <Library/BaseLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/DebugLib.h>
+#include <Library/PcdLib.h>
+
+#include <IndustryStandard/Acpi.h>
+
+EFI_STATUS
+EFIAPI
+InstallAcpiTable (
+  IN   EFI_ACPI_TABLE_PROTOCOL       *AcpiProtocol,
+  IN   VOID                          *AcpiTableBuffer,
+  IN   UINTN                         AcpiTableBufferSize,
+  OUT  UINTN                         *TableKey
+  );
+
+BOOLEAN
+QemuDetected (
+  VOID
+  );
+
+EFI_STATUS
+EFIAPI
+QemuInstallAcpiTable (
+  IN   EFI_ACPI_TABLE_PROTOCOL       *AcpiProtocol,
+  IN   VOID                          *AcpiTableBuffer,
+  IN   UINTN                         AcpiTableBufferSize,
+  OUT  UINTN                         *TableKey
+  );
+
+#endif
+
diff --git a/corebootPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf b/corebootPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
new file mode 100644
index 0000000..b0be444
--- /dev/null
+++ b/corebootPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
@@ -0,0 +1,64 @@
+## @file
+#  OVMF ACPI Platform Driver
+#
+#  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = AcpiPlatform
+  FILE_GUID                      = 49970331-E3FA-4637-9ABC-3B7868676970
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = AcpiPlatformEntryPoint
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  AcpiPlatform.c
+  Qemu.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  corebootPkg/corebootPkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+  PcAtChipsetPkg/PcAtChipsetPkg.dec
+
+[LibraryClasses]
+  UefiLib
+  DxeServicesLib
+  PcdLib
+  BaseMemoryLib
+  DebugLib
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  HobLib
+  QemuFwCfgLib
+  MemoryAllocationLib
+  BaseLib
+  DxeServicesTableLib
+
+[Protocols]
+  gEfiAcpiTableProtocolGuid                     # PROTOCOL ALWAYS_CONSUMED
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiTableStorageFile
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuLocalApicBaseAddress
+  gPcAtChipsetPkgTokenSpaceGuid.Pcd8259LegacyModeEdgeLevel
+
+[Depex]
+  gEfiAcpiTableProtocolGuid
+
diff --git a/corebootPkg/Csm/Csm16/Csm16.inf b/corebootPkg/Csm/Csm16/Csm16.inf
new file mode 100644
index 0000000..61f972b
--- /dev/null
+++ b/corebootPkg/Csm/Csm16/Csm16.inf
@@ -0,0 +1,23 @@
+## @file
+#  CSM Binary
+#
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = Csm16
+  FILE_GUID                      = 1547B4F3-3E8A-4FEF-81C8-328ED647AB1A
+  MODULE_TYPE                    = USER_DEFINED
+  VERSION_STRING                 = 1.0
+
+[Binaries]
+  BIN|Csm16.bin|*
\ No newline at end of file
diff --git a/corebootPkg/Csm/Csm16/ReadMe.txt b/corebootPkg/Csm/Csm16/ReadMe.txt
new file mode 100644
index 0000000..4d5d086
--- /dev/null
+++ b/corebootPkg/Csm/Csm16/ReadMe.txt
@@ -0,0 +1,12 @@
+This module allows a CSM16 binary to be easily included
+in the OVMF.fd output file.
+
+=== How to use Csm16.inf ===
+
+1. Copy the CSM16 binary to OvmfPkg/Csm/Csm16/Csm16.bin
+2. Build OVMF with CSM_ENABLE defined.
+
+   For example:
+   * build -D CSM_ENABLE, or
+   * OvmfPkg/build.sh -D CSM_ENABLE
+
diff --git a/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.c b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.c
new file mode 100644
index 0000000..c0b0252
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.c
@@ -0,0 +1,38 @@
+/** @file
+  Platform CSM Support Library
+
+  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "CsmSupportLib.h"
+
+/**
+  The constructor function for the platform CSM support library
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+CsmSupportLibConstructor (
+  VOID
+  )
+{
+  LegacyRegionInit ();
+
+  LegacyInterruptInstall ();
+
+  LegacyBiosPlatformInstall ();
+
+  return EFI_SUCCESS;
+}
+
diff --git a/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.h b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.h
new file mode 100644
index 0000000..e3b6e8c
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.h
@@ -0,0 +1,55 @@
+/** @file
+  Platform CSM Support Library
+
+  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _CSM_SUPPORT_LIB_H_
+#define _CSM_SUPPORT_LIB_H_
+
+#include <Uefi.h>
+
+/**
+  Initialize Legacy Region support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyRegionInit (
+  VOID
+  );
+
+/**
+  Initialize Legacy Interrupt support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyInterruptInstall (
+  VOID
+  );
+
+/**
+  Initialize Legacy Platform support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyBiosPlatformInstall (
+  VOID
+  );
+
+#endif
+
diff --git a/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.inf b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.inf
new file mode 100644
index 0000000..34cadb2
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/CsmSupportLib.inf
@@ -0,0 +1,54 @@
+## @file
+#  Platform CSM Support Library
+#
+#  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = CsmSupportLib
+  FILE_GUID                      = 04e03541-4663-417d-93f6-976378247d61
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = CsmSupportLib
+
+  CONSTRUCTOR                    = CsmSupportLibConstructor
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  CsmSupportLib.c
+  LegacyInterrupt.c
+  LegacyRegion.c
+  LegacyPlatform.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  IntelFrameworkPkg/IntelFrameworkPkg.dec
+
+[Protocols]
+  gEfiDevicePathProtocolGuid                    # PROTOCOL ALWAYS_CONSUMED
+  gEfiDiskInfoProtocolGuid                      # PROTOCOL ALWAYS_CONSUMED
+  gEfiLegacyBiosPlatformProtocolGuid            # PROTOCOL ALWAYS_CONSUMED
+  gEfiLegacyBiosProtocolGuid                    # PROTOCOL ALWAYS_CONSUMED
+  gEfiLegacyInterruptProtocolGuid               # PROTOCOL ALWAYS_PRODUCED
+  gEfiLegacyRegion2ProtocolGuid                 # PROTOCOL ALWAYS_PRODUCED
+  gEfiPciIoProtocolGuid                         # PROTOCOL ALWAYS_CONSUMED
+
+[LibraryClasses]
+  BaseLib
+  PciLib
+  IoLib
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.c b/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.c
new file mode 100644
index 0000000..cd98417
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.c
@@ -0,0 +1,196 @@
+/** @file
+  Legacy Interrupt Support
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "LegacyInterrupt.h"
+
+//
+// Handle for the Legacy Interrupt Protocol instance produced by this driver
+//
+STATIC EFI_HANDLE mLegacyInterruptHandle = NULL;
+
+//
+// The Legacy Interrupt Protocol instance produced by this driver
+//
+STATIC EFI_LEGACY_INTERRUPT_PROTOCOL mLegacyInterrupt = {
+  GetNumberPirqs,
+  GetLocation,
+  ReadPirq,
+  WritePirq
+};
+
+STATIC UINT8 PirqReg[MAX_PIRQ_NUMBER] = { PIRQA, PIRQB, PIRQC, PIRQD, PIRQE, PIRQF, PIRQG, PIRQH };
+
+
+/**
+  Return the number of PIRQs supported by this chipset.
+
+  @param[in]  This         Pointer to LegacyInterrupt Protocol
+  @param[out] NumberPirqs  The pointer to return the max IRQ number supported
+
+  @retval EFI_SUCCESS   Max PIRQs successfully returned
+
+**/
+EFI_STATUS
+EFIAPI
+GetNumberPirqs (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  OUT UINT8                          *NumberPirqs
+  )
+{
+  *NumberPirqs = MAX_PIRQ_NUMBER;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Return PCI location of this device.
+  $PIR table requires this info.
+
+  @param[in]   This                - Protocol instance pointer.
+  @param[out]  Bus                 - PCI Bus
+  @param[out]  Device              - PCI Device
+  @param[out]  Function            - PCI Function
+
+  @retval  EFI_SUCCESS   Bus/Device/Function returned
+
+**/
+EFI_STATUS
+EFIAPI
+GetLocation (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  OUT UINT8                          *Bus,
+  OUT UINT8                          *Device,
+  OUT UINT8                          *Function
+  )
+{
+  *Bus      = LEGACY_INT_BUS;
+  *Device   = LEGACY_INT_DEV;
+  *Function = LEGACY_INT_FUNC;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Builds the PCI configuration address for the register specified by PirqNumber
+
+  @param[in]  PirqNumber - The PIRQ number to build the PCI configuration address for
+
+  @return  The PCI Configuration address for the PIRQ
+**/
+UINTN
+GetAddress (
+  UINT8  PirqNumber
+  )
+{
+  return PCI_LIB_ADDRESS(
+          LEGACY_INT_BUS,
+          LEGACY_INT_DEV,
+          LEGACY_INT_FUNC,
+          PirqReg[PirqNumber]
+          );
+}
+
+/**
+  Read the given PIRQ register
+
+  @param[in]  This        Protocol instance pointer
+  @param[in]  PirqNumber  The Pirq register 0 = A, 1 = B etc
+  @param[out] PirqData    Value read
+
+  @retval EFI_SUCCESS   Decoding change affected.
+  @retval EFI_INVALID_PARAMETER   Invalid PIRQ number
+
+**/
+EFI_STATUS
+EFIAPI
+ReadPirq (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  IN  UINT8                          PirqNumber,
+  OUT UINT8                          *PirqData
+  )
+{
+  if (PirqNumber >= MAX_PIRQ_NUMBER) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *PirqData = PciRead8 (GetAddress (PirqNumber));
+  *PirqData = (UINT8) (*PirqData & 0x7f);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Write the given PIRQ register
+
+  @param[in]  This        Protocol instance pointer
+  @param[in]  PirqNumber  The Pirq register 0 = A, 1 = B etc
+  @param[out] PirqData    Value to write
+
+  @retval EFI_SUCCESS   Decoding change affected.
+  @retval EFI_INVALID_PARAMETER   Invalid PIRQ number
+
+**/
+EFI_STATUS
+EFIAPI
+WritePirq (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  IN  UINT8                          PirqNumber,
+  IN  UINT8                          PirqData
+  )
+{
+  if (PirqNumber >= MAX_PIRQ_NUMBER) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  PciWrite8 (GetAddress (PirqNumber), PirqData);
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Initialize Legacy Interrupt support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyInterruptInstall (
+  VOID
+  )
+{
+  EFI_STATUS  Status;
+
+  //
+  // Make sure the Legacy Interrupt Protocol is not already installed in the system
+  //
+  ASSERT_PROTOCOL_ALREADY_INSTALLED(NULL, &gEfiLegacyInterruptProtocolGuid);
+
+  //
+  // Make a new handle and install the protocol
+  //
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &mLegacyInterruptHandle,
+                  &gEfiLegacyInterruptProtocolGuid,
+                  &mLegacyInterrupt,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR(Status);
+
+  return Status;
+}
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.h b/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.h
new file mode 100644
index 0000000..193e48b
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyInterrupt.h
@@ -0,0 +1,119 @@
+/** @file
+  Legacy Region Support
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _LEGACY_INTERRUPT_H_
+#define _LEGACY_INTERRUPT_H_
+
+#include <PiDxe.h>
+
+#include <Protocol/LegacyInterrupt.h>
+
+#include <Library/PciLib.h>
+#include <Library/DebugLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+
+#define LEGACY_INT_BUS  0
+#define LEGACY_INT_DEV  1
+#define LEGACY_INT_FUNC 0
+
+#define PIRQN           0x00  // PIRQ Null
+#define PIRQA           0x60
+#define PIRQB           0x61
+#define PIRQC           0x62
+#define PIRQD           0x63
+#define PIRQE           0x68
+#define PIRQF           0x69
+#define PIRQG           0x6A
+#define PIRQH           0x6B
+
+#define MAX_PIRQ_NUMBER 8
+
+/**
+  Return the number of PIRQs supported by this chipset.
+
+  @param[in]  This         Pointer to LegacyInterrupt Protocol
+  @param[out] NumberPirqs  The pointer to return the max IRQ number supported
+
+  @retval EFI_SUCCESS   Max PIRQs successfully returned
+
+**/
+EFI_STATUS
+EFIAPI
+GetNumberPirqs (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  OUT UINT8                          *NumberPirqs
+  );
+
+/**
+  Return PCI location of this device.
+  $PIR table requires this info.
+
+  @param[in]   This                - Protocol instance pointer.
+  @param[out]  Bus                 - PCI Bus
+  @param[out]  Device              - PCI Device
+  @param[out]  Function            - PCI Function
+
+  @retval  EFI_SUCCESS   Bus/Device/Function returned
+
+**/
+EFI_STATUS
+EFIAPI
+GetLocation (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  OUT UINT8                          *Bus,
+  OUT UINT8                          *Device,
+  OUT UINT8                          *Function
+  );
+
+/**
+  Read the given PIRQ register
+
+  @param[in]  This        Protocol instance pointer
+  @param[in]  PirqNumber  The Pirq register 0 = A, 1 = B etc
+  @param[out] PirqData    Value read
+
+  @retval EFI_SUCCESS   Decoding change affected.
+  @retval EFI_INVALID_PARAMETER   Invalid PIRQ number
+
+**/
+EFI_STATUS
+EFIAPI
+ReadPirq (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  IN  UINT8                          PirqNumber,
+  OUT UINT8                          *PirqData
+  );
+
+/**
+  Write the given PIRQ register
+
+  @param[in]  This        Protocol instance pointer
+  @param[in]  PirqNumber  The Pirq register 0 = A, 1 = B etc
+  @param[out] PirqData    Value to write
+
+  @retval EFI_SUCCESS   Decoding change affected.
+  @retval EFI_INVALID_PARAMETER   Invalid PIRQ number
+
+**/
+EFI_STATUS
+EFIAPI
+WritePirq (
+  IN  EFI_LEGACY_INTERRUPT_PROTOCOL  *This,
+  IN  UINT8                          PirqNumber,
+  IN  UINT8                          PirqData
+  );
+
+#endif
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.c b/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.c
new file mode 100644
index 0000000..af8896a
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.c
@@ -0,0 +1,1066 @@
+/** @file
+  Legacy BIOS Platform support
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "LegacyPlatform.h"
+
+EFI_SETUP_BBS_MAP mSetupBbsMap[] = {
+  { 1, 2,     1, 1 },     // ATA HardDrive
+  { 2, 3,     1, 1 },     // ATAPI CDROM
+  { 3, 0x80,  2, 0 },     // PXE
+  { 4, 1,     0, 6 },     // USB Floppy
+  { 4, 2,     0, 6 },     // USB HDD
+  { 4, 3,     0, 6 },     // USB CD
+  { 4, 1,     0, 0 },     // USB ZIP Bugbug since Class/SubClass code is uninitialized
+  { 4, 2,     0, 0 }      // USB ZIP Bugbug since Class/SubClass code is uninitialized
+};
+
+//
+// Global variables for System ROMs
+//
+#define SYSTEM_ROM_FILE_GUID \
+{ 0x1547B4F3, 0x3E8A, 0x4FEF, 0x81, 0xC8, 0x32, 0x8E, 0xD6, 0x47, 0xAB, 0x1A }
+
+#define NULL_ROM_FILE_GUID \
+{ 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+
+SYSTEM_ROM_TABLE mSystemRomTable[] = {
+  { SYSTEM_ROM_FILE_GUID,  1 },
+  { NULL_ROM_FILE_GUID,    0 }
+};
+
+EFI_HANDLE  mVgaHandles[0x20];
+EFI_HANDLE  mDiskHandles[0x20];
+EFI_HANDLE  mIsaHandles[0x20];
+
+EFI_LEGACY_IRQ_PRIORITY_TABLE_ENTRY IrqPriorityTable[MAX_IRQ_PRIORITY_ENTRIES] = {
+  {0x0B,0},
+  {0x09,0},
+  {0x0A,0},
+  {0x05,0},
+  {0x07,0},
+  {0x00,0},
+  {0x00,0}
+};
+
+//
+// PIRQ Table
+// - Slot numbering will be used to update the bus number and determine bridge
+//   to check to get bus number.  The Slot number - 1 is an index into a decode
+//   table to get the bridge information.
+//
+EFI_LEGACY_PIRQ_TABLE PirqTableHead = {
+  {
+    EFI_LEGACY_PIRQ_TABLE_SIGNATURE, // UINT32  Signature
+    0x00,             // UINT8   MinorVersion
+    0x01,             // UINT8   MajorVersion
+    0x0000,           // UINT16  TableSize
+    0x00,             // UINT8   Bus
+    0x08,             // UINT8   DevFun
+    0x0000,           // UINT16  PciOnlyIrq
+    0x8086,           // UINT16  CompatibleVid
+    0x122e,           // UINT16  CompatibleDid
+    0x00000000,       // UINT32  Miniport
+    {                 // UINT8   Reserved[11]
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00
+    },
+    0x00,             // UINT8   Checksum
+  },
+  {
+    //          -- Pin 1 -- -- Pin 2 -- -- Pin 3 -- -- Pin 4 --
+    // Bus  Dev  Reg   Map   Reg   Map   Reg   Map   Reg   Map
+
+    0x00,0x08,0x60,0xDEB8,0x61,0xDEB8,0x62,0xDEB8,0x63,0xDEB8,0x00,0x00,
+    0x00,0x10,0x61,0xDEB8,0x62,0xDEB8,0x63,0xDEB8,0x60,0xDEB8,0x01,0x00,
+    0x00,0x18,0x62,0xDEB8,0x63,0xDEB8,0x60,0xDEB8,0x61,0xDEB8,0x02,0x00,
+    0x00,0x20,0x63,0xDEB8,0x60,0xDEB8,0x61,0xDEB8,0x62,0xDEB8,0x03,0x00,
+    0x00,0x28,0x60,0xDEB8,0x61,0xDEB8,0x62,0xDEB8,0x63,0xDEB8,0x04,0x00,
+    0x00,0x30,0x61,0xDEB8,0x62,0xDEB8,0x63,0xDEB8,0x60,0xDEB8,0x05,0x00,
+  }
+};
+
+LEGACY_BIOS_PLATFORM_INSTANCE       mPrivateData;
+EFI_HANDLE                          mImageHandle = NULL;
+
+/**
+  Return the handles and assorted information for the specified PCI Class code
+
+  @param[in]     PciClasses    Array of PCI_CLASS_RECORD to find terminated with ClassCode 0xff
+  @param[in,out] DeviceTable   Table to place handles etc in.
+  @param[in,out] DeviceIndex   Number of devices found
+  @param[in]     DeviceFlags   FALSE if a valid legacy ROM is required, TRUE otherwise.
+
+  @retval EFI_SUCCESS     One or more devices found
+  @retval EFI_NOT_FOUND   No device found
+
+**/
+EFI_STATUS
+FindAllDeviceTypes (
+  IN       PCI_CLASS_RECORD      *PciClasses,
+  IN OUT   DEVICE_STRUCTURE      *DeviceTable,
+  IN OUT   UINT16                *DeviceIndex,
+  IN       BOOLEAN               DeviceFlags
+  )
+{
+  UINTN                       HandleCount;
+  EFI_HANDLE                  *HandleBuffer;
+  UINTN                       Index;
+  UINTN                       StartIndex;
+  PCI_TYPE00                  PciConfigHeader;
+  EFI_PCI_IO_PROTOCOL         *PciIo;
+  EFI_LEGACY_BIOS_PROTOCOL    *LegacyBios;
+  UINTN                       Flags;
+  EFI_STATUS                  Status;
+  UINTN                       Index2;
+
+  //
+  // Get legacy BIOS protocol as it is required to deal with Option ROMs.
+  //
+  StartIndex = *DeviceIndex;
+  Status = gBS->LocateProtocol (
+                  &gEfiLegacyBiosProtocolGuid,
+                  NULL,
+                  (VOID**)&LegacyBios
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Get all PCI handles and check them to generate a list of matching devices.
+  //
+  gBS->LocateHandleBuffer (
+         ByProtocol,
+         &gEfiPciIoProtocolGuid,
+         NULL,
+         &HandleCount,
+         &HandleBuffer
+         );
+  for (Index = 0; Index < HandleCount; Index++) {
+    gBS->HandleProtocol (
+           HandleBuffer[Index],
+           &gEfiPciIoProtocolGuid,
+           (VOID**)&PciIo
+           );
+    PciIo->Pci.Read (
+                 PciIo,
+                 EfiPciIoWidthUint32,
+                 0,
+                 sizeof (PciConfigHeader) / sizeof (UINT32),
+                 &PciConfigHeader
+                 );
+    for (Index2 = 0; PciClasses[Index2].Class != 0xff; Index2++) {
+        if ((PciConfigHeader.Hdr.ClassCode[2] == PciClasses[Index2].Class) &&
+            (PciConfigHeader.Hdr.ClassCode[1] == PciClasses[Index2].SubClass)) {
+        LegacyBios->CheckPciRom (
+                      LegacyBios,
+                      HandleBuffer[Index],
+                      NULL,
+                      NULL,
+                      &Flags
+                      );
+
+        //
+        // Verify that results of OPROM check match request.
+        // The two valid requests are:
+        //   DeviceFlags = 0 require a valid legacy ROM
+        //   DeviceFlags = 1 require either no ROM or a valid legacy ROM
+        //
+        if (
+            ((DeviceFlags != 0) && (Flags == NO_ROM)) ||
+            ((Flags & (ROM_FOUND | VALID_LEGACY_ROM)) == (ROM_FOUND | VALID_LEGACY_ROM))
+           ) {
+          DeviceTable->Handle = HandleBuffer[Index];
+          DeviceTable->Vid    = PciConfigHeader.Hdr.VendorId;
+          DeviceTable->Did    = PciConfigHeader.Hdr.DeviceId;
+          DeviceTable->SvId   = PciConfigHeader.Device.SubsystemVendorID;
+          DeviceTable->SysId  = PciConfigHeader.Device.SubsystemID;
+          ++ *DeviceIndex;
+          DeviceTable++;
+        }
+      }
+    }
+  }
+
+  //
+  // Free any allocated buffers
+  //
+  gBS->FreePool (HandleBuffer);
+
+  if (*DeviceIndex != StartIndex) {
+    return EFI_SUCCESS;
+  } else {
+    return EFI_NOT_FOUND;
+  }
+}
+
+/**
+  Load and initialize the Legacy BIOS SMM handler.
+
+  @param  This                   The protocol instance pointer.
+  @param  EfiToLegacy16BootTable A pointer to Legacy16 boot table.
+
+  @retval EFI_SUCCESS           SMM code loaded.
+  @retval EFI_DEVICE_ERROR      SMM code failed to load
+
+**/
+EFI_STATUS
+EFIAPI
+SmmInit (
+  IN  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  IN  VOID                                        *EfiToLegacy16BootTable
+  )
+{
+  return EFI_SUCCESS;
+}
+
+/**
+  Finds the device path that should be used as the primary display adapter.
+
+  @param  VgaHandle - The handle of the video device
+
+**/
+VOID
+GetSelectedVgaDeviceInfo (
+  OUT EFI_HANDLE                *VgaHandle
+  )
+{
+  EFI_STATUS                Status;
+  UINTN                     HandleCount;
+  EFI_HANDLE                *HandleBuffer;
+  UINTN                     Index;
+  EFI_PCI_IO_PROTOCOL       *PciIo;
+  PCI_TYPE00                Pci;
+  UINT8                     MinBus;
+  UINT8                     MaxBus;
+  UINTN                     Segment;
+  UINTN                     Bus;
+  UINTN                     Device;
+  UINTN                     Function;
+  UINTN                     SelectedAddress;
+  UINTN                     CurrentAddress;
+
+  //
+  // Initialize return to 'not found' state
+  //
+  *VgaHandle = NULL;
+
+  //
+  // Initialize variable states.  Ths is important for selecting the VGA device
+  // if multiple devices exist behind a single bridge.
+  //
+  HandleCount = 0;
+  HandleBuffer = NULL;
+  SelectedAddress = PCI_LIB_ADDRESS(0xff, 0x1f, 0x7, 0);
+
+  //
+  // The bus range to search for a VGA device in.
+  //
+  MinBus = MaxBus = 0;
+
+  //
+  // Start to check all the pci io to find all possible VGA device
+  //
+  HandleCount = 0;
+  HandleBuffer = NULL;
+  Status = gBS->LocateHandleBuffer (
+                  ByProtocol,
+                  &gEfiPciIoProtocolGuid,
+                  NULL,
+                  &HandleCount,
+                  &HandleBuffer
+                  );
+  if (EFI_ERROR (Status)) {
+    return;
+  }
+
+  for (Index = 0; Index < HandleCount; Index++) {
+    Status = gBS->HandleProtocol (HandleBuffer[Index], &gEfiPciIoProtocolGuid, (VOID**)&PciIo);
+    if (!EFI_ERROR (Status)) {
+      //
+      // Detemine if this is in the correct bus range.
+      //
+      Status = PciIo->GetLocation (PciIo, &Segment, &Bus, &Device, &Function);
+      if (EFI_ERROR(Status) || (Bus < MinBus || Bus > MaxBus)) {
+        continue;
+      }
+
+      //
+      // Read device information.
+      //
+      Status = PciIo->Pci.Read (
+                        PciIo,
+                        EfiPciIoWidthUint32,
+                        0,
+                        sizeof (Pci) / sizeof (UINT32),
+                        &Pci
+                        );
+      if (EFI_ERROR (Status)) {
+        continue;
+      }
+
+      //
+      // Make sure the device is a VGA device.
+      //
+      if (!IS_PCI_VGA (&Pci)) {
+        continue;
+      }
+      DEBUG ((EFI_D_INFO,
+        "PCI VGA: 0x%04x:0x%04x\n",
+        Pci.Hdr.VendorId,
+        Pci.Hdr.DeviceId
+        ));
+
+      //
+      // Currently we use the lowest numbered bus/device/function if multiple
+      // devices are found in the target bus range.
+      //
+      CurrentAddress = PCI_LIB_ADDRESS(Bus, Device, Function, 0);
+      if (CurrentAddress < SelectedAddress) {
+        SelectedAddress = CurrentAddress;
+        *VgaHandle = HandleBuffer[Index];
+      }
+    }
+  }
+
+  FreePool (HandleBuffer);
+}
+
+
+/**
+  Returns a buffer of handles for the requested subfunction.
+
+  @param  This                  The protocol instance pointer.
+  @param  Mode                  Specifies what handle to return. See EFI_GET_PLATFORM_HANDLE_MODE enum.
+  @param  Type                  Mode specific. See EFI_GET_PLATFORM_HANDLE_MODE enum.
+  @param  HandleBuffer          Mode specific. See EFI_GET_PLATFORM_HANDLE_MODE enum.
+  @param  HandleCount           Mode specific. See EFI_GET_PLATFORM_HANDLE_MODE enum.
+  @param  AdditionalData        Mode specific. See EFI_GET_PLATFORM_HANDLE_MODE enum.
+
+  @retval EFI_SUCCESS           Handle is valid.
+  @retval EFI_UNSUPPORTED       Mode is not supported on the platform.
+  @retval EFI_NOT_FOUND         Handle is not known.
+
+**/
+EFI_STATUS
+EFIAPI
+GetPlatformHandle (
+  IN  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  IN  EFI_GET_PLATFORM_HANDLE_MODE                Mode,
+  IN  UINT16                                      Type,
+  OUT EFI_HANDLE                                  **HandleBuffer,
+  OUT UINTN                                       *HandleCount,
+  OUT VOID                                        **AdditionalData OPTIONAL
+  )
+{
+  DEVICE_STRUCTURE    LocalDevice[0x40];
+  UINT32              LocalIndex;
+  UINT32              Index;
+  DEVICE_STRUCTURE    TempDevice;
+  EFI_STATUS          Status;
+  EFI_PCI_IO_PROTOCOL *PciIo;
+  UINTN               Segment;
+  UINTN               Bus;
+  UINTN               Device;
+  UINTN               Function;
+  HDD_INFO            *HddInfo;
+  PCI_TYPE00          PciConfigHeader;
+  UINT32              HddIndex;
+  EFI_HANDLE          IdeHandle;
+  EFI_LEGACY_BIOS_PROTOCOL  *LegacyBios;
+  PCI_CLASS_RECORD    ClassLists[10];
+  UINTN               PriorityIndex;
+
+  static BOOLEAN      bConnected = FALSE;
+
+  LocalIndex  = 0x00;
+  HddInfo     = NULL;
+  HddIndex    = 0;
+
+  Status = gBS->LocateProtocol (
+                  &gEfiLegacyBiosProtocolGuid,
+                  NULL,
+                  (VOID**)&LegacyBios
+                  );
+
+  //
+  // Process mode specific operations
+  //
+  switch (Mode) {
+    case EfiGetPlatformVgaHandle:
+      //
+      // Get the handle for the currently selected VGA device.
+      //
+      GetSelectedVgaDeviceInfo (&mVgaHandles[0]);
+      *HandleBuffer = &mVgaHandles[0];
+      *HandleCount  = (mVgaHandles[0] != NULL) ? 1 : 0;
+      return EFI_SUCCESS;
+    case EfiGetPlatformIdeHandle:
+      IdeHandle  = NULL;
+      if (AdditionalData != NULL) {
+        HddInfo = (HDD_INFO *) *AdditionalData;
+      }
+
+      //
+      // Locate all found block io devices
+      //
+      ClassLists[0].Class    = PCI_CLASS_MASS_STORAGE;
+      ClassLists[0].SubClass = PCI_CLASS_MASS_STORAGE_SCSI;
+      ClassLists[1].Class    = PCI_CLASS_MASS_STORAGE;
+      ClassLists[1].SubClass = PCI_CLASS_MASS_STORAGE_IDE;
+      ClassLists[2].Class    = PCI_CLASS_MASS_STORAGE;
+      ClassLists[2].SubClass = PCI_CLASS_MASS_STORAGE_RAID;
+      ClassLists[3].Class    = PCI_CLASS_MASS_STORAGE;
+      ClassLists[3].SubClass = PCI_CLASS_MASS_STORAGE_SATADPA;
+      ClassLists[4].Class    = 0xff;
+      FindAllDeviceTypes (ClassLists, LocalDevice, (UINT16 *) &LocalIndex, TRUE);
+      if (LocalIndex == 0) {
+        return EFI_NOT_FOUND;
+      }
+
+      //
+      // Make sure all IDE controllers are connected. This is necessary
+      // in NO_CONFIG_CHANGE boot path to ensure IDE controller is correctly
+      // initialized and all IDE drives are enumerated
+      //
+      if (!bConnected) {
+        for (Index = 0; Index < LocalIndex; Index++) {
+          gBS->ConnectController (LocalDevice[Index].Handle, NULL, NULL, TRUE);
+        }
+      }
+
+      //
+      // Locate onboard controllers.
+      //
+      for (Index = 0; Index < LocalIndex; Index++) {
+        if (LocalDevice[Index].Vid == V_INTEL_VENDOR_ID) {
+          if (LocalDevice[Index].Did == V_PIIX4_IDE_DEVICE_ID) {
+            IdeHandle = LocalDevice[Index].Handle;
+          }
+        }
+      }
+
+      //
+      // Set the IDE contorller as primary devices.
+      //
+      PriorityIndex = 0;
+      for (Index = 0; Index < LocalIndex; Index++) {
+        if (LocalDevice[Index].Handle == IdeHandle && PriorityIndex == 0) {
+          TempDevice = LocalDevice[PriorityIndex];
+          LocalDevice[PriorityIndex] = LocalDevice[Index];
+          LocalDevice[Index] = TempDevice;
+          PriorityIndex++;
+          break;
+        }
+      }
+
+      //
+      // Copy over handles and update return values.
+      //
+      for (Index = 0; Index < LocalIndex; Index++) {
+        mDiskHandles[Index] = LocalDevice[Index].Handle;
+      }
+      *HandleBuffer = &mDiskHandles[0];
+      *HandleCount  = LocalIndex;
+
+      //
+      // We have connected all IDE controllers once. No more needed
+      //
+      bConnected = TRUE;
+
+      //
+      // Log all onboard controllers.
+      //
+      for (Index = 0; (Index < LocalIndex) && (AdditionalData != NULL); Index++) {
+        if ((LocalDevice[Index].Handle != NULL) &&
+            (LocalDevice[Index].Handle == IdeHandle)) {
+          Status = gBS->HandleProtocol (
+                          LocalDevice[Index].Handle,
+                          &gEfiPciIoProtocolGuid,
+                          (VOID **) &PciIo
+                          );
+          PciIo->Pci.Read (
+                       PciIo,
+                       EfiPciIoWidthUint32,
+                       0,
+                       sizeof (PciConfigHeader) / sizeof (UINT32),
+                       &PciConfigHeader
+                       );
+          if (!EFI_ERROR (Status)) {
+            PciIo->GetLocation (
+                     PciIo,
+                     &Segment,
+                     &Bus,
+                     &Device,
+                     &Function
+                     );
+
+            //
+            // Be sure to only fill out correct information based on platform
+            // configureation.
+            //
+            HddInfo[HddIndex].Status        |= HDD_PRIMARY;
+            HddInfo[HddIndex].Bus           = (UINT32)Bus;
+            HddInfo[HddIndex].Device        = (UINT32)Device;
+            HddInfo[HddIndex].Function      = (UINT32)Function;
+            HddInfo[HddIndex + 1].Status    |= HDD_SECONDARY;
+            HddInfo[HddIndex + 1].Bus       = (UINT32)Bus;
+            HddInfo[HddIndex + 1].Device    = (UINT32)Device;
+            HddInfo[HddIndex + 1].Function  = (UINT32)Function;
+
+            //
+            // Primary controller data
+            //
+            if ((PciConfigHeader.Hdr.ClassCode[0] & 0x01) != 0) {
+              HddInfo[HddIndex].CommandBaseAddress =
+                (UINT16)(PciConfigHeader.Device.Bar[0] & 0xfffc);
+              HddInfo[HddIndex].ControlBaseAddress =
+                (UINT16)((PciConfigHeader.Device.Bar[1] & 0xfffc)+2);
+              HddInfo[HddIndex].BusMasterAddress =
+                (UINT16)(PciConfigHeader.Device.Bar[4] & 0xfffc);
+              HddInfo[HddIndex].HddIrq = PciConfigHeader.Device.InterruptLine;
+            } else {
+              HddInfo[HddIndex].HddIrq = 14;
+              HddInfo[HddIndex].CommandBaseAddress = 0x1f0;
+              HddInfo[HddIndex].ControlBaseAddress = 0x3f6;
+              HddInfo[HddIndex].BusMasterAddress = 0;
+            }
+            HddIndex++;
+
+            //
+            // Secondary controller data
+            //
+            if ((PciConfigHeader.Hdr.ClassCode[0] & 0x04) != 0) {
+              HddInfo[HddIndex].CommandBaseAddress =
+                (UINT16)(PciConfigHeader.Device.Bar[2] & 0xfffc);
+              HddInfo[HddIndex].ControlBaseAddress =
+                (UINT16)((PciConfigHeader.Device.Bar[3] & 0xfffc)+2);
+              HddInfo[HddIndex].BusMasterAddress =
+                (UINT16)(HddInfo[HddIndex].BusMasterAddress + 8);
+              HddInfo[HddIndex].HddIrq = PciConfigHeader.Device.InterruptLine;
+            } else {
+              HddInfo[HddIndex].HddIrq = 15;
+              HddInfo[HddIndex].CommandBaseAddress = 0x170;
+              HddInfo[HddIndex].ControlBaseAddress = 0x376;
+              HddInfo[HddIndex].BusMasterAddress = 0;
+            }
+            HddIndex++;
+          }
+        }
+      }
+      return EFI_SUCCESS;
+    case EfiGetPlatformIsaBusHandle:
+      ClassLists[0].Class    = (UINT8) PCI_CLASS_BRIDGE;
+      ClassLists[0].SubClass = (UINT8) PCI_CLASS_BRIDGE_ISA_PDECODE;
+      ClassLists[1].Class    = (UINT8) PCI_CLASS_BRIDGE;
+      ClassLists[1].SubClass = (UINT8) PCI_CLASS_BRIDGE_ISA;
+      ClassLists[2].Class    = 0xff;
+
+      //
+      // Locate all found block io devices
+      //
+      FindAllDeviceTypes (ClassLists, LocalDevice, (UINT16 *) (&LocalIndex), TRUE);
+      if (LocalIndex == 0) {
+        return EFI_NOT_FOUND;
+      }
+
+      //
+      // Find our ISA bridge.
+      //
+      for (Index = 0; Index < LocalIndex; Index++) {
+        if (LocalDevice[Index].Vid == V_INTEL_VENDOR_ID) {
+          TempDevice          = LocalDevice[0];
+          LocalDevice[0]      = LocalDevice[Index];
+          LocalDevice[Index]  = TempDevice;
+        }
+      }
+
+      //
+      // Perform copy and update return values.
+      //
+      for (Index = 0; Index < LocalIndex; Index++) {
+        mIsaHandles[Index] = LocalDevice[Index].Handle;
+      }
+      *HandleBuffer = &mIsaHandles[0];
+      *HandleCount  = LocalIndex;
+      return EFI_SUCCESS;
+    case EfiGetPlatformUsbHandle:
+    default:
+      return EFI_UNSUPPORTED;
+  };
+}
+
+/**
+  Allows platform to perform any required action after a LegacyBios operation.
+  Invokes the specific sub function specified by Mode.
+
+  @param  This                  The protocol instance pointer.
+  @param  Mode                  Specifies what handle to return. See EFI_GET_PLATFORM_HOOK_MODE enum.
+  @param  Type                  Mode specific.  See EFI_GET_PLATFORM_HOOK_MODE enum.
+  @param  DeviceHandle          Mode specific.  See EFI_GET_PLATFORM_HOOK_MODE enum.
+  @param  ShadowAddress         Mode specific.  See EFI_GET_PLATFORM_HOOK_MODE enum.
+  @param  Compatibility16Table  Mode specific.  See EFI_GET_PLATFORM_HOOK_MODE enum.
+  @param  AdditionalData        Mode specific.  See EFI_GET_PLATFORM_HOOK_MODE enum.
+
+  @retval EFI_SUCCESS           The operation performed successfully. Mode specific.
+  @retval EFI_UNSUPPORTED       Mode is not supported on the platform.
+
+**/
+EFI_STATUS
+EFIAPI
+PlatformHooks (
+  IN       EFI_LEGACY_BIOS_PLATFORM_PROTOCOL     *This,
+  IN       EFI_GET_PLATFORM_HOOK_MODE            Mode,
+  IN       UINT16                                Type,
+     OUT   EFI_HANDLE                            DeviceHandle, OPTIONAL
+  IN OUT   UINTN                                 *Shadowaddress, OPTIONAL
+  IN       EFI_COMPATIBILITY16_TABLE             *Compatibility16Table, OPTIONAL
+     OUT   VOID                                  **AdditionalData OPTIONAL
+  )
+{
+  EFI_IA32_REGISTER_SET     Regs;
+  EFI_LEGACY_BIOS_PROTOCOL  *LegacyBios;
+  EFI_STATUS                Status;
+
+  switch (Mode) {
+    case EfiPlatformHookPrepareToScanRom:
+      Status = gBS->LocateProtocol (
+                      &gEfiLegacyBiosProtocolGuid,
+                      NULL,
+                      (VOID**)&LegacyBios
+                      );
+
+      //
+      // Set the 80x25 Text VGA Mode
+      //
+      Regs.H.AH = 0x00;
+      Regs.H.AL = 0x03;
+      Status = LegacyBios->Int86 (LegacyBios, 0x10, &Regs);
+      return Status;
+    case EfiPlatformHookShadowServiceRoms:
+      return EFI_SUCCESS;
+    case EfiPlatformHookAfterRomInit:
+    default:
+      return EFI_UNSUPPORTED;
+  };
+}
+
+/**
+  Returns information associated with PCI IRQ routing.
+  This function returns the following information associated with PCI IRQ routing:
+    * An IRQ routing table and number of entries in the table.
+    * The $PIR table and its size.
+    * A list of PCI IRQs and the priority order to assign them.
+
+  @param  This                    The protocol instance pointer.
+  @param  RoutingTable            The pointer to PCI IRQ Routing table.
+                                  This location is the $PIR table minus the header.
+  @param  RoutingTableEntries     The number of entries in table.
+  @param  LocalPirqTable          $PIR table.
+  @param  PirqTableSize           $PIR table size.
+  @param  LocalIrqPriorityTable   A list of interrupts in priority order to assign.
+  @param  IrqPriorityTableEntries The number of entries in the priority table.
+
+  @retval EFI_SUCCESS           Data was successfully returned.
+
+**/
+EFI_STATUS
+EFIAPI
+GetRoutingTable (
+  IN  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  OUT VOID                                        **RoutingTable,
+  OUT UINTN                                       *RoutingTableEntries,
+  OUT VOID                                        **LocalPirqTable, OPTIONAL
+  OUT UINTN                                       *PirqTableSize, OPTIONAL
+  OUT VOID                                        **LocalIrqPriorityTable, OPTIONAL
+  OUT UINTN                                       *IrqPriorityTableEntries OPTIONAL
+  )
+{
+  UINT16                        PTableSize;
+  UINT32                        Index;
+  UINT8                         Bus;
+  UINT8                         Device;
+  UINT8                         Function;
+  UINT8                         Checksum;
+  UINT8                         *Ptr;
+  EFI_STATUS                    Status;
+  EFI_LEGACY_INTERRUPT_PROTOCOL *LegacyInterrupt;
+
+  Checksum = 0;
+
+  if (LocalPirqTable != NULL) {
+    PTableSize = sizeof (EFI_LEGACY_PIRQ_TABLE_HEADER) +
+                 sizeof (EFI_LEGACY_IRQ_ROUTING_ENTRY) * MAX_IRQ_ROUTING_ENTRIES;
+
+    Status = gBS->LocateProtocol (
+                    &gEfiLegacyInterruptProtocolGuid,
+                    NULL,
+                    (VOID**)&LegacyInterrupt
+                    );
+    ASSERT_EFI_ERROR (Status);
+    LegacyInterrupt->GetLocation (
+                       LegacyInterrupt,
+                       &Bus,
+                       &Device,
+                       &Function
+                       );
+
+    //
+    // Update fields in $PIR table header
+    //
+    PirqTableHead.PirqTable.TableSize = PTableSize;
+    PirqTableHead.PirqTable.Bus       = Bus;
+    PirqTableHead.PirqTable.DevFun    = (UINT8) ((Device << 3) + Function);
+    Ptr = (UINT8 *) (&PirqTableHead);
+
+    //
+    // Calculate checksum.
+    //
+    for (Index = 0; Index < PTableSize; Index++) {
+      Checksum = (UINT8) (Checksum + (UINT8) *Ptr);
+      Ptr += 1;
+    }
+    Checksum                          = (UINT8) (0x00 - Checksum);
+    PirqTableHead.PirqTable.Checksum  = Checksum;
+
+    //
+    // Update return values.
+    //
+    *LocalPirqTable                   = (VOID *) (&PirqTableHead);
+    *PirqTableSize                    = PTableSize;
+  }
+
+  //
+  // More items to return.
+  //
+  *RoutingTable         = PirqTableHead.IrqRoutingEntry;
+  *RoutingTableEntries  = MAX_IRQ_ROUTING_ENTRIES;
+  if (LocalIrqPriorityTable != NULL) {
+    *LocalIrqPriorityTable    = IrqPriorityTable;
+    *IrqPriorityTableEntries  = MAX_IRQ_PRIORITY_ENTRIES;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Finds the binary data or other platform information.
+
+  @param  This                  The protocol instance pointer.
+  @param  Mode                  Specifies what data to return. See See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  Table                 Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  TableSize             Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  Location              Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  Alignment             Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  LegacySegment         Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+  @param  LegacyOffset          Mode specific.  See EFI_GET_PLATFORM_INFO_MODE enum.
+
+  @retval EFI_SUCCESS           Data returned successfully.
+  @retval EFI_UNSUPPORTED       Mode is not supported on the platform.
+  @retval EFI_NOT_FOUND         Binary image or table not found.
+
+**/
+EFI_STATUS
+EFIAPI
+GetPlatformInfo (
+  IN  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  IN  EFI_GET_PLATFORM_INFO_MODE                  Mode,
+  OUT VOID                                        **Table,
+  OUT UINTN                                       *TableSize,
+  OUT UINTN                                       *Location,
+  OUT UINTN                                       *Alignment,
+  IN  UINT16                                      LegacySegment,
+  IN  UINT16                                      LegacyOffset
+  )
+{
+  EFI_STATUS                    Status;
+  UINTN                         Index;
+
+  switch (Mode) {
+    case EfiGetPlatformBinarySystemRom:
+      //
+      // Loop through table of System rom descriptions
+      //
+      for (Index = 0; mSystemRomTable[Index].Valid != 0; Index++) {
+        Status = GetSectionFromFv (
+                   &mSystemRomTable[Index].FileName,
+                   EFI_SECTION_RAW,
+                   0,
+                   Table,
+                   (UINTN *) TableSize
+                   );
+        if (EFI_ERROR (Status)) {
+          continue;
+        }
+        return EFI_SUCCESS;
+      }
+
+      return EFI_NOT_FOUND;
+    case EfiGetPlatformBinaryOem16Data:
+    case EfiGetPlatformBinaryMpTable:
+    case EfiGetPlatformBinaryOemIntData:
+    case EfiGetPlatformBinaryOem32Data:
+    case EfiGetPlatformBinaryTpmBinary:
+    case EfiGetPlatformPciExpressBase:
+    default:
+      return EFI_UNSUPPORTED;
+  };
+}
+
+/**
+  Translates the given PIRQ accounting for bridge.
+  This function translates the given PIRQ back through all buses, if required,
+  and returns the true PIRQ and associated IRQ.
+
+  @param  This                  The protocol instance pointer.
+  @param  PciBus                The PCI bus number for this device.
+  @param  PciDevice             The PCI device number for this device.
+  @param  PciFunction           The PCI function number for this device.
+  @param  Pirq                  Input is PIRQ reported by device, and output is true PIRQ.
+  @param  PciIrq                The IRQ already assigned to the PIRQ, or the IRQ to be
+                                assigned to the PIRQ.
+
+  @retval EFI_SUCCESS           The PIRQ was translated.
+
+**/
+EFI_STATUS
+EFIAPI
+TranslatePirq (
+  IN        EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  IN        UINTN                                       PciBus,
+  IN        UINTN                                       PciDevice,
+  IN        UINTN                                       PciFunction,
+  IN  OUT   UINT8                                       *Pirq,
+      OUT   UINT8                                       *PciIrq
+  )
+{
+  EFI_LEGACY_INTERRUPT_PROTOCOL      *LegacyInterrupt;
+  EFI_STATUS                         Status;
+  UINTN                              Index;
+  UINTN                              Index1;
+  UINT8                              LocalPirq;
+  UINT8                              PirqData;
+  UINT8                              MatchData;
+
+  Status = gBS->LocateProtocol (
+                  &gEfiLegacyInterruptProtocolGuid,
+                  NULL,
+                  (VOID**)&LegacyInterrupt
+                  );
+  ASSERT_EFI_ERROR (Status);
+  LocalPirq = (UINT8) (*Pirq);
+
+  for (Index = 0; Index < MAX_IRQ_ROUTING_ENTRIES; Index++) {
+    if ((PirqTableHead.IrqRoutingEntry[Index].Bus == PciBus) &&
+        (PirqTableHead.IrqRoutingEntry[Index].Device == PciDevice)) {
+      LocalPirq = (UINT8) (PirqTableHead.IrqRoutingEntry[Index].PirqEntry[LocalPirq].Pirq & 0x0f);
+      if (LocalPirq > 4) {
+        LocalPirq -= 4;
+      }
+
+      LegacyInterrupt->ReadPirq (LegacyInterrupt, LocalPirq, &PirqData);
+      MatchData = PCI_UNUSED;
+      while (PirqData == 0) {
+        for (Index1 = 0; Index1 < MAX_IRQ_PRIORITY_ENTRIES; Index1++) {
+          if ((IrqPriorityTable[Index1].Used == MatchData) &&
+              (IrqPriorityTable[Index1].Irq != 0)) {
+            PirqData = IrqPriorityTable[Index1].Irq;
+            IrqPriorityTable[Index1].Used = 0xff;
+            LegacyInterrupt->WritePirq (
+                               LegacyInterrupt,
+                               LocalPirq,
+                               PirqData
+                               );
+            break;
+          }
+        }
+
+        if (PirqData == 0) {
+
+          //
+          // No unused interrpts, so start reusing them.
+          //
+          MatchData = (UINT8) (~MatchData);
+        }
+      }
+
+      *PciIrq = PirqData;
+      *Pirq   = LocalPirq;
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Attempt to legacy boot the BootOption. If the EFI contexted has been
+  compromised this function will not return.
+
+  @param  This                   The protocol instance pointer.
+  @param  BbsDevicePath          The EFI Device Path from BootXXXX variable.
+  @param  BbsTable               The Internal BBS table.
+  @param  LoadOptionSize         The size of LoadOption in size.
+  @param  LoadOption             The LoadOption from BootXXXX variable
+  @param  EfiToLegacy16BootTable A pointer to BootTable structure
+
+  @retval EFI_SUCCESS           Ready to boot.
+
+**/
+EFI_STATUS
+EFIAPI
+PrepareToBoot (
+  IN  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL           *This,
+  IN  BBS_BBS_DEVICE_PATH                         *BbsDevicePath,
+  IN  VOID                                        *BbsTable,
+  IN  UINT32                                      LoadOptionsSize,
+  IN  VOID                                        *LoadOptions,
+  IN  VOID                                        *EfiToLegacy16BootTable
+  )
+{
+  BBS_TABLE                           *LocalBbsTable;
+  EFI_TO_COMPATIBILITY16_BOOT_TABLE   *Legacy16BootTable;
+  DEVICE_PRODUCER_DATA_HEADER         *SioPtr;
+  UINT16                              DevicePathType;
+  UINT16                              Index;
+  UINT16                              Priority;
+
+  //
+  // Initialize values
+  //
+  Priority = 0;
+  Legacy16BootTable = (EFI_TO_COMPATIBILITY16_BOOT_TABLE*) EfiToLegacy16BootTable;
+
+  //
+  // Set how Gate A20 is gated by hardware
+  //
+  SioPtr                  = &Legacy16BootTable->SioData;
+  SioPtr->Flags.A20Kybd   = 1;
+  SioPtr->Flags.A20Port90 = 1;
+  SioPtr->MousePresent    = 1;
+
+  LocalBbsTable           = BbsTable;
+
+  //
+  // There are 2 cases that must be covered.
+  // Case 1: Booting to a legacy OS - BbsDevicePath is non-NULL.
+  // Case 2: Booting to an EFI aware OS - BbsDevicePath is NULL.
+  //         We need to perform the PrepareToBoot function to assign
+  //         drive numbers to HDD devices to allow the shell or EFI
+  //         to access them.
+  //
+  if (BbsDevicePath != NULL) {
+    DevicePathType = BbsDevicePath->DeviceType;
+  } else {
+    DevicePathType = BBS_HARDDISK;
+  }
+
+  //
+  // Skip the boot devices where priority is set by BDS and set the next one
+  //
+  for (Index = 0; Index < Legacy16BootTable->NumberBbsEntries; Index++) {
+    if ((LocalBbsTable[Index].BootPriority != BBS_UNPRIORITIZED_ENTRY) &&
+        (LocalBbsTable[Index].BootPriority != BBS_IGNORE_ENTRY) &&
+        (LocalBbsTable[Index].BootPriority != BBS_LOWEST_PRIORITY) &&
+        (Priority <= LocalBbsTable[Index].BootPriority)) {
+      Priority = (UINT16) (LocalBbsTable[Index].BootPriority + 1);
+    }
+  }
+
+  switch (DevicePathType) {
+    case BBS_FLOPPY:
+    case BBS_HARDDISK:
+    case BBS_CDROM:
+    case BBS_EMBED_NETWORK:
+      for (Index = 0; Index < Legacy16BootTable->NumberBbsEntries; Index++) {
+        if ((LocalBbsTable[Index].BootPriority == BBS_UNPRIORITIZED_ENTRY) &&
+            (LocalBbsTable[Index].DeviceType == DevicePathType)) {
+          LocalBbsTable[Index].BootPriority = Priority;
+          ++Priority;
+        }
+      }
+      break;
+    case BBS_BEV_DEVICE:
+      for (Index = 0; Index < Legacy16BootTable->NumberBbsEntries; Index++) {
+        if ((LocalBbsTable[Index].BootPriority == BBS_UNPRIORITIZED_ENTRY) &&
+            (LocalBbsTable[Index].Class == 01) &&
+            (LocalBbsTable[Index].SubClass == 01)) {
+          LocalBbsTable[Index].BootPriority = Priority;
+          ++Priority;
+        }
+      }
+      break;
+    case BBS_USB:
+    case BBS_PCMCIA:
+    case BBS_UNKNOWN:
+    default:
+      break;
+  };
+
+  //
+  // Set priority for rest of devices
+  //
+  for (Index = 0; Index < Legacy16BootTable->NumberBbsEntries; Index++) {
+    if (LocalBbsTable[Index].BootPriority == BBS_UNPRIORITIZED_ENTRY) {
+      LocalBbsTable[Index].BootPriority = Priority;
+      ++Priority;
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Initialize Legacy Platform support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyBiosPlatformInstall (
+  VOID
+  )
+{
+  EFI_STATUS                           Status;
+  LEGACY_BIOS_PLATFORM_INSTANCE        *Private;
+
+  mImageHandle = gImageHandle;
+  Private = &mPrivateData;
+
+  //
+  // Grab a copy of all the protocols we depend on.
+  //
+  Private->Signature = LEGACY_BIOS_PLATFORM_INSTANCE_SIGNATURE;
+  Private->LegacyBiosPlatform.GetPlatformInfo   = GetPlatformInfo;
+  Private->LegacyBiosPlatform.GetPlatformHandle = GetPlatformHandle;
+  Private->LegacyBiosPlatform.SmmInit           = SmmInit;
+  Private->LegacyBiosPlatform.PlatformHooks     = PlatformHooks;
+  Private->LegacyBiosPlatform.GetRoutingTable   = GetRoutingTable;
+  Private->LegacyBiosPlatform.TranslatePirq     = TranslatePirq;
+  Private->LegacyBiosPlatform.PrepareToBoot     = PrepareToBoot;
+  Private->ImageHandle = gImageHandle;
+
+  //
+  // Make a new handle and install the protocol
+  //
+  Private->Handle = NULL;
+  Status = gBS->InstallProtocolInterface (
+                  &Private->Handle,
+                  &gEfiLegacyBiosPlatformProtocolGuid,
+                  EFI_NATIVE_INTERFACE,
+                  &Private->LegacyBiosPlatform
+                  );
+  return Status;
+}
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.h b/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.h
new file mode 100644
index 0000000..a4654a4
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyPlatform.h
@@ -0,0 +1,104 @@
+/** @file
+  Legacy BIOS Platform support
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef LEGACY_BIOS_PLATFORM_H_
+#define LEGACY_BIOS_PLATFORM_H_
+
+#include <FrameworkDxe.h>
+
+#include <Protocol/PciIo.h>
+#include <Protocol/PciRootBridgeIo.h>
+#include <Protocol/DevicePath.h>
+#include <Protocol/LegacyInterrupt.h>
+#include <Protocol/LegacyRegion2.h>
+#include <Protocol/LegacyBiosPlatform.h>
+#include <Protocol/FirmwareVolume.h>
+#include <Protocol/DiskInfo.h>
+
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/IoLib.h>
+#include <Library/PciLib.h>
+#include <Library/PcdLib.h>
+#include <Library/DxeServicesLib.h>
+#include <Library/DevicePathLib.h>
+
+#include <IndustryStandard/Pci.h>
+
+//
+// PIRQ information constants.
+//
+#define MAX_IRQ_ROUTING_ENTRIES     6
+#define MAX_IRQ_PRIORITY_ENTRIES    7
+
+#define V_INTEL_VENDOR_ID         0x8086
+#define V_PIIX4_IDE_DEVICE_ID     0x7010
+
+//
+// Type declarations
+//
+typedef struct {
+  UINT8   SetupValue;
+  UINT16  DeviceType;
+  UINT8   Class;
+  UINT8   SubClass;
+} EFI_SETUP_BBS_MAP;
+
+typedef struct {
+  UINT8          Class;
+  UINT8          SubClass;
+} PCI_CLASS_RECORD;
+
+typedef struct {
+  EFI_LEGACY_PIRQ_TABLE_HEADER  PirqTable;
+  EFI_LEGACY_IRQ_ROUTING_ENTRY  IrqRoutingEntry[MAX_IRQ_ROUTING_ENTRIES];
+} EFI_LEGACY_PIRQ_TABLE;
+
+typedef struct {
+  EFI_HANDLE  Handle;
+  UINT16      Vid;
+  UINT16      Did;
+  UINT16      SvId;
+  UINT16      SysId;
+} DEVICE_STRUCTURE;
+
+typedef struct {
+  EFI_GUID  FileName;
+  UINTN     Valid;
+} SYSTEM_ROM_TABLE;
+
+typedef struct {
+  UINT32                            Signature;
+  EFI_HANDLE                        Handle;
+  EFI_LEGACY_BIOS_PLATFORM_PROTOCOL LegacyBiosPlatform;
+  EFI_HANDLE                        ImageHandle;
+  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL   *PciRootBridgeIo;
+} LEGACY_BIOS_PLATFORM_INSTANCE;
+
+#define LEGACY_BIOS_PLATFORM_INSTANCE_SIGNATURE   SIGNATURE_32('P','B','I','O')
+
+#define LEGACY_BIOS_PLATFORM_INSTANCE_FROM_THIS(this) \
+  CR (this, \
+      LEGACY_BIOS_PLATFORM_INSTANCE, \
+      LegacyBiosPlatform, \
+      LEGACY_BIOS_PLATFORM_INSTANCE_SIGNATURE \
+      )
+
+#endif
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyRegion.c b/corebootPkg/Csm/CsmSupportLib/LegacyRegion.c
new file mode 100644
index 0000000..44d340b
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyRegion.c
@@ -0,0 +1,466 @@
+/** @file
+  Legacy Region Support
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "LegacyRegion.h"
+
+//
+// 440 PAM map.
+//
+// PAM Range       Offset  Bits  Operation
+// =============== ======  ====  ===============================================================
+// 0xC0000-0xC3FFF  0x5a   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xC4000-0xC7FFF  0x5a   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xC8000-0xCBFFF  0x5b   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xCC000-0xCFFFF  0x5b   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xD0000-0xD3FFF  0x5c   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xD4000-0xD7FFF  0x5c   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xD8000-0xDBFFF  0x5d   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xDC000-0xDFFFF  0x5d   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xE0000-0xE3FFF  0x5e   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xE4000-0xE7FFF  0x5e   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xE8000-0xEBFFF  0x5f   1:0   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xEC000-0xEFFFF  0x5f   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+// 0xF0000-0xFFFFF  0x59   5:4   00 = DRAM Disabled, 01= Read Only, 10 = Write Only, 11 = Normal
+//
+STATIC LEGACY_MEMORY_SECTION_INFO   mSectionArray[] = {
+  {0xC0000, SIZE_16KB, FALSE, FALSE},
+  {0xC4000, SIZE_16KB, FALSE, FALSE},
+  {0xC8000, SIZE_16KB, FALSE, FALSE},
+  {0xCC000, SIZE_16KB, FALSE, FALSE},
+  {0xD0000, SIZE_16KB, FALSE, FALSE},
+  {0xD4000, SIZE_16KB, FALSE, FALSE},
+  {0xD8000, SIZE_16KB, FALSE, FALSE},
+  {0xDC000, SIZE_16KB, FALSE, FALSE},
+  {0xE0000, SIZE_16KB, FALSE, FALSE},
+  {0xE4000, SIZE_16KB, FALSE, FALSE},
+  {0xE8000, SIZE_16KB, FALSE, FALSE},
+  {0xEC000, SIZE_16KB, FALSE, FALSE},
+  {0xF0000, SIZE_64KB, FALSE, FALSE}
+};
+
+STATIC PAM_REGISTER_VALUE  mRegisterValues[] = {
+  {REG_PAM1_OFFSET, 0x01, 0x02},
+  {REG_PAM1_OFFSET, 0x10, 0x20},
+  {REG_PAM2_OFFSET, 0x01, 0x02},
+  {REG_PAM2_OFFSET, 0x10, 0x20},
+  {REG_PAM3_OFFSET, 0x01, 0x02},
+  {REG_PAM3_OFFSET, 0x10, 0x20},
+  {REG_PAM4_OFFSET, 0x01, 0x02},
+  {REG_PAM4_OFFSET, 0x10, 0x20},
+  {REG_PAM5_OFFSET, 0x01, 0x02},
+  {REG_PAM5_OFFSET, 0x10, 0x20},
+  {REG_PAM6_OFFSET, 0x01, 0x02},
+  {REG_PAM6_OFFSET, 0x10, 0x20},
+  {REG_PAM0_OFFSET, 0x10, 0x20}
+};
+
+//
+// Handle used to install the Legacy Region Protocol
+//
+STATIC EFI_HANDLE  mHandle = NULL;
+
+//
+// Instance of the Legacy Region Protocol to install into the handle database
+//
+STATIC EFI_LEGACY_REGION2_PROTOCOL  mLegacyRegion2 = {
+  LegacyRegion2Decode,
+  LegacyRegion2Lock,
+  LegacyRegion2BootLock,
+  LegacyRegion2Unlock,
+  LegacyRegionGetInfo
+};
+
+STATIC
+EFI_STATUS
+LegacyRegionManipulationInternal (
+  IN  UINT32                  Start,
+  IN  UINT32                  Length,
+  IN  BOOLEAN                 *ReadEnable,
+  IN  BOOLEAN                 *WriteEnable,
+  OUT UINT32                  *Granularity
+  )
+{
+  UINT32                        EndAddress;
+  UINTN                         Index;
+  UINTN                         StartIndex;
+
+  //
+  // Validate input parameters.
+  //
+  if (Length == 0 || Granularity == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+  EndAddress = Start + Length - 1;
+  if ((Start < PAM_BASE_ADDRESS) || EndAddress > PAM_LIMIT_ADDRESS) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Loop to find the start PAM.
+  //
+  StartIndex = 0;
+  for (Index = 0; Index < (sizeof(mSectionArray) / sizeof (mSectionArray[0])); Index++) {
+    if ((Start >= mSectionArray[Index].Start) && (Start < (mSectionArray[Index].Start + mSectionArray[Index].Length))) {
+      StartIndex = Index;
+      break;
+    }
+  }
+  ASSERT (Index < (sizeof(mSectionArray) / sizeof (mSectionArray[0])));
+
+  //
+  // Program PAM until end PAM is encountered
+  //
+  for (Index = StartIndex; Index < (sizeof(mSectionArray) / sizeof (mSectionArray[0])); Index++) {
+    if (ReadEnable != NULL) {
+      if (*ReadEnable) {
+        PciOr8 (
+          PCI_LIB_ADDRESS(PAM_PCI_BUS, PAM_PCI_DEV, PAM_PCI_FUNC, mRegisterValues[Index].PAMRegOffset),
+          mRegisterValues[Index].ReadEnableData
+          );
+      } else {
+        PciAnd8 (
+          PCI_LIB_ADDRESS(PAM_PCI_BUS, PAM_PCI_DEV, PAM_PCI_FUNC, mRegisterValues[Index].PAMRegOffset),
+          (UINT8) (~mRegisterValues[Index].ReadEnableData)
+          );
+      }
+    }
+    if (WriteEnable != NULL) {
+      if (*WriteEnable) {
+        PciOr8 (
+          PCI_LIB_ADDRESS(PAM_PCI_BUS, PAM_PCI_DEV, PAM_PCI_FUNC, mRegisterValues[Index].PAMRegOffset),
+          mRegisterValues[Index].WriteEnableData
+          );
+      } else {
+        PciAnd8 (
+          PCI_LIB_ADDRESS(PAM_PCI_BUS, PAM_PCI_DEV, PAM_PCI_FUNC, mRegisterValues[Index].PAMRegOffset),
+          (UINT8) (~mRegisterValues[Index].WriteEnableData)
+          );
+      }
+    }
+
+    //
+    // If the end PAM is encountered, record its length as granularity and jump out.
+    //
+    if ((EndAddress >= mSectionArray[Index].Start) && (EndAddress < (mSectionArray[Index].Start + mSectionArray[Index].Length))) {
+      *Granularity = mSectionArray[Index].Length;
+      break;
+    }
+  }
+  ASSERT (Index < (sizeof(mSectionArray) / sizeof (mSectionArray[0])));
+
+  return EFI_SUCCESS;
+}
+
+STATIC
+EFI_STATUS
+LegacyRegionGetInfoInternal (
+  OUT UINT32                        *DescriptorCount,
+  OUT LEGACY_MEMORY_SECTION_INFO    **Descriptor
+  )
+{
+  UINTN    Index;
+  UINT8    PamValue;
+
+  //
+  // Check input parameters
+  //
+  if (DescriptorCount == NULL || Descriptor == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Fill in current status of legacy region.
+  //
+  *DescriptorCount = sizeof(mSectionArray) / sizeof (mSectionArray[0]);
+  for (Index = 0; Index < *DescriptorCount; Index++) {
+    PamValue = PciRead8 (PCI_LIB_ADDRESS(PAM_PCI_BUS, PAM_PCI_DEV, PAM_PCI_FUNC, mRegisterValues[Index].PAMRegOffset));
+    mSectionArray[Index].ReadEnabled = FALSE;
+    if ((PamValue & mRegisterValues[Index].ReadEnableData) != 0) {
+      mSectionArray[Index].ReadEnabled = TRUE;
+    }
+    mSectionArray[Index].WriteEnabled = FALSE;
+    if ((PamValue & mRegisterValues[Index].WriteEnableData) != 0) {
+      mSectionArray[Index].WriteEnabled = TRUE;
+    }
+  }
+
+  *Descriptor = mSectionArray;
+  return EFI_SUCCESS;
+}
+
+/**
+  Modify the hardware to allow (decode) or disallow (not decode) memory reads in a region.
+
+  If the On parameter evaluates to TRUE, this function enables memory reads in the address range
+  Start to (Start + Length - 1).
+  If the On parameter evaluates to FALSE, this function disables memory reads in the address range
+  Start to (Start + Length - 1).
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose attributes
+                                should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address
+                                was not aligned to a region's starting address or if the length
+                                was greater than the number of bytes in the first region.
+  @param  On[in]                Decode / Non-Decode flag.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Decode (
+  IN  EFI_LEGACY_REGION2_PROTOCOL  *This,
+  IN  UINT32                       Start,
+  IN  UINT32                       Length,
+  OUT UINT32                       *Granularity,
+  IN  BOOLEAN                      *On
+  )
+{
+  return LegacyRegionManipulationInternal (Start, Length, On, NULL, Granularity);
+}
+
+
+/**
+  Modify the hardware to disallow memory attribute changes in a region.
+
+  This function makes the attributes of a region read only. Once a region is boot-locked with this
+  function, the read and write attributes of that region cannot be changed until a power cycle has
+  reset the boot-lock attribute. Calls to Decode(), Lock() and Unlock() will have no effect.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+  @retval EFI_UNSUPPORTED       The chipset does not support locking the configuration registers in
+                                a way that will not affect memory regions outside the legacy memory
+                                region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2BootLock (
+  IN  EFI_LEGACY_REGION2_PROTOCOL         *This,
+  IN  UINT32                              Start,
+  IN  UINT32                              Length,
+  OUT UINT32                              *Granularity
+  )
+{
+  if ((Start < 0xC0000) || ((Start + Length - 1) > 0xFFFFF)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  return EFI_UNSUPPORTED;
+}
+
+
+/**
+  Modify the hardware to disallow memory writes in a region.
+
+  This function changes the attributes of a memory range to not allow writes.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Lock (
+  IN  EFI_LEGACY_REGION2_PROTOCOL *This,
+  IN  UINT32                      Start,
+  IN  UINT32                      Length,
+  OUT UINT32                      *Granularity
+  )
+{
+  BOOLEAN  WriteEnable;
+
+  WriteEnable = FALSE;
+  return LegacyRegionManipulationInternal (Start, Length, NULL, &WriteEnable, Granularity);
+}
+
+
+/**
+  Modify the hardware to allow memory writes in a region.
+
+  This function changes the attributes of a memory range to allow writes.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Unlock (
+  IN  EFI_LEGACY_REGION2_PROTOCOL  *This,
+  IN  UINT32                       Start,
+  IN  UINT32                       Length,
+  OUT UINT32                       *Granularity
+  )
+{
+  BOOLEAN  WriteEnable;
+
+  WriteEnable = TRUE;
+  return LegacyRegionManipulationInternal (Start, Length, NULL, &WriteEnable, Granularity);
+}
+
+/**
+  Get region information for the attributes of the Legacy Region.
+
+  This function is used to discover the granularity of the attributes for the memory in the legacy
+  region. Each attribute may have a different granularity and the granularity may not be the same
+  for all memory ranges in the legacy region.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  DescriptorCount[out]  The number of region descriptor entries returned in the Descriptor
+                                buffer.
+  @param  Descriptor[out]       A pointer to a pointer used to return a buffer where the legacy
+                                region information is deposited. This buffer will contain a list of
+                                DescriptorCount number of region descriptors.  This function will
+                                provide the memory for the buffer.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegionGetInfo (
+  IN  EFI_LEGACY_REGION2_PROTOCOL   *This,
+  OUT UINT32                        *DescriptorCount,
+  OUT EFI_LEGACY_REGION_DESCRIPTOR  **Descriptor
+  )
+{
+  LEGACY_MEMORY_SECTION_INFO   *SectionInfo;
+  UINT32                       SectionCount;
+  EFI_LEGACY_REGION_DESCRIPTOR *DescriptorArray;
+  UINTN                        Index;
+  UINTN                        DescriptorIndex;
+
+  //
+  // Get section numbers and information
+  //
+  LegacyRegionGetInfoInternal (&SectionCount, &SectionInfo);
+
+  //
+  // Each section has 3 descriptors, corresponding to readability, writeability, and lock status.
+  //
+  DescriptorArray = AllocatePool (sizeof (EFI_LEGACY_REGION_DESCRIPTOR) * SectionCount * 3);
+  if (DescriptorArray == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  DescriptorIndex = 0;
+  for (Index = 0; Index < SectionCount; Index++) {
+    DescriptorArray[DescriptorIndex].Start       = SectionInfo[Index].Start;
+    DescriptorArray[DescriptorIndex].Length      = SectionInfo[Index].Length;
+    DescriptorArray[DescriptorIndex].Granularity = SectionInfo[Index].Length;
+    if (SectionInfo[Index].ReadEnabled) {
+      DescriptorArray[DescriptorIndex].Attribute   = LegacyRegionDecoded;
+    } else {
+      DescriptorArray[DescriptorIndex].Attribute   = LegacyRegionNotDecoded;
+    }
+    DescriptorIndex++;
+
+    //
+    // Create descriptor for writeability, according to lock status
+    //
+    DescriptorArray[DescriptorIndex].Start       = SectionInfo[Index].Start;
+    DescriptorArray[DescriptorIndex].Length      = SectionInfo[Index].Length;
+    DescriptorArray[DescriptorIndex].Granularity = SectionInfo[Index].Length;
+    if (SectionInfo[Index].WriteEnabled) {
+      DescriptorArray[DescriptorIndex].Attribute = LegacyRegionWriteEnabled;
+    } else {
+      DescriptorArray[DescriptorIndex].Attribute = LegacyRegionWriteDisabled;
+    }
+    DescriptorIndex++;
+
+    //
+    // Chipset does not support bootlock.
+    //
+    DescriptorArray[DescriptorIndex].Start       = SectionInfo[Index].Start;
+    DescriptorArray[DescriptorIndex].Length      = SectionInfo[Index].Length;
+    DescriptorArray[DescriptorIndex].Granularity = SectionInfo[Index].Length;
+    DescriptorArray[DescriptorIndex].Attribute   = LegacyRegionNotLocked;
+    DescriptorIndex++;
+  }
+
+  *DescriptorCount = (UINT32) DescriptorIndex;
+  *Descriptor      = DescriptorArray;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Initialize Legacy Region support
+
+  @retval EFI_SUCCESS   Successfully initialized
+
+**/
+EFI_STATUS
+LegacyRegionInit (
+  VOID
+  )
+{
+  EFI_STATUS  Status;
+
+  //
+  // Install the Legacy Region Protocol on a new handle
+  //
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &mHandle,
+                  &gEfiLegacyRegion2ProtocolGuid, &mLegacyRegion2,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  return Status;
+}
+
diff --git a/corebootPkg/Csm/CsmSupportLib/LegacyRegion.h b/corebootPkg/Csm/CsmSupportLib/LegacyRegion.h
new file mode 100644
index 0000000..805df86
--- /dev/null
+++ b/corebootPkg/Csm/CsmSupportLib/LegacyRegion.h
@@ -0,0 +1,219 @@
+/** @file
+  Legacy Region Support
+
+  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _LEGACY_REGION_DXE_H_
+#define _LEGACY_REGION_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Protocol/LegacyRegion2.h>
+
+#include <IndustryStandard/Pci.h>
+
+#include <Library/PciLib.h>
+#include <Library/PcdLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+
+#define PAM_PCI_BUS        0
+#define PAM_PCI_DEV        0
+#define PAM_PCI_FUNC       0
+
+#define REG_PAM0_OFFSET    0x59    // Programmable Attribute Map 0
+#define REG_PAM1_OFFSET    0x5a    // Programmable Attribute Map 1
+#define REG_PAM2_OFFSET    0x5b    // Programmable Attribute Map 2
+#define REG_PAM3_OFFSET    0x5c    // Programmable Attribute Map 3
+#define REG_PAM4_OFFSET    0x5d    // Programmable Attribute Map 4
+#define REG_PAM5_OFFSET    0x5e    // Programmable Attribute Map 5
+#define REG_PAM6_OFFSET    0x5f    // Programmable Attribute Map 6
+
+#define PAM_BASE_ADDRESS   0xc0000
+#define PAM_LIMIT_ADDRESS  BASE_1MB
+
+//
+// Describes Legacy Region blocks and status.
+//
+typedef struct {
+  UINT32  Start;
+  UINT32  Length;
+  BOOLEAN ReadEnabled;
+  BOOLEAN WriteEnabled;
+} LEGACY_MEMORY_SECTION_INFO;
+
+//
+// Provides a map of the PAM registers and bits used to set Read/Write access.
+//
+typedef struct {
+  UINT8   PAMRegOffset;
+  UINT8   ReadEnableData;
+  UINT8   WriteEnableData;
+} PAM_REGISTER_VALUE;
+
+/**
+  Modify the hardware to allow (decode) or disallow (not decode) memory reads in a region.
+
+  If the On parameter evaluates to TRUE, this function enables memory reads in the address range
+  Start to (Start + Length - 1).
+  If the On parameter evaluates to FALSE, this function disables memory reads in the address range
+  Start to (Start + Length - 1).
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose attributes
+                                should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address
+                                was not aligned to a region's starting address or if the length
+                                was greater than the number of bytes in the first region.
+  @param  On[in]                Decode / Non-Decode flag.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Decode (
+  IN  EFI_LEGACY_REGION2_PROTOCOL  *This,
+  IN  UINT32                       Start,
+  IN  UINT32                       Length,
+  OUT UINT32                       *Granularity,
+  IN  BOOLEAN                      *On
+  );
+
+/**
+  Modify the hardware to disallow memory writes in a region.
+
+  This function changes the attributes of a memory range to not allow writes.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Lock (
+  IN  EFI_LEGACY_REGION2_PROTOCOL *This,
+  IN  UINT32                      Start,
+  IN  UINT32                      Length,
+  OUT UINT32                      *Granularity
+  );
+
+/**
+  Modify the hardware to disallow memory attribute changes in a region.
+
+  This function makes the attributes of a region read only. Once a region is boot-locked with this
+  function, the read and write attributes of that region cannot be changed until a power cycle has
+  reset the boot-lock attribute. Calls to Decode(), Lock() and Unlock() will have no effect.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+  @retval EFI_UNSUPPORTED       The chipset does not support locking the configuration registers in
+                                a way that will not affect memory regions outside the legacy memory
+                                region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2BootLock (
+  IN EFI_LEGACY_REGION2_PROTOCOL          *This,
+  IN  UINT32                              Start,
+  IN  UINT32                              Length,
+  OUT UINT32                              *Granularity
+  );
+
+/**
+  Modify the hardware to allow memory writes in a region.
+
+  This function changes the attributes of a memory range to allow writes.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  Start[in]             The beginning of the physical address of the region whose
+                                attributes should be modified.
+  @param  Length[in]            The number of bytes of memory whose attributes should be modified.
+                                The actual number of bytes modified may be greater than the number
+                                specified.
+  @param  Granularity[out]      The number of bytes in the last region affected. This may be less
+                                than the total number of bytes affected if the starting address was
+                                not aligned to a region's starting address or if the length was
+                                greater than the number of bytes in the first region.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegion2Unlock (
+  IN  EFI_LEGACY_REGION2_PROTOCOL  *This,
+  IN  UINT32                       Start,
+  IN  UINT32                       Length,
+  OUT UINT32                       *Granularity
+  );
+
+/**
+  Get region information for the attributes of the Legacy Region.
+
+  This function is used to discover the granularity of the attributes for the memory in the legacy
+  region. Each attribute may have a different granularity and the granularity may not be the same
+  for all memory ranges in the legacy region.
+
+  @param  This[in]              Indicates the EFI_LEGACY_REGION_PROTOCOL instance.
+  @param  DescriptorCount[out]  The number of region descriptor entries returned in the Descriptor
+                                buffer.
+  @param  Descriptor[out]       A pointer to a pointer used to return a buffer where the legacy
+                                region information is deposited. This buffer will contain a list of
+                                DescriptorCount number of region descriptors.  This function will
+                                provide the memory for the buffer.
+
+  @retval EFI_SUCCESS           The region's attributes were successfully modified.
+  @retval EFI_INVALID_PARAMETER If Start or Length describe an address not in the Legacy Region.
+
+**/
+EFI_STATUS
+EFIAPI
+LegacyRegionGetInfo (
+  IN  EFI_LEGACY_REGION2_PROTOCOL   *This,
+  OUT UINT32                        *DescriptorCount,
+  OUT EFI_LEGACY_REGION_DESCRIPTOR  **Descriptor
+  );
+
+#endif
+
diff --git a/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.c b/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.c
new file mode 100644
index 0000000..c644128
--- /dev/null
+++ b/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.c
@@ -0,0 +1,304 @@
+/** @file
+  ACPI Timer implements one instance of Timer Library.
+
+  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011, Andrei Warkentin <andreiw@motorola.com>
+
+  This program and the accompanying materials are
+  licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Base.h>
+#include <Library/TimerLib.h>
+#include <Library/BaseLib.h>
+#include <Library/IoLib.h>
+#include <Library/PciLib.h>
+#include <Library/DebugLib.h>
+#include <Library/PcdLib.h>
+#include <IndustryStandard/Pci22.h>
+#include <IndustryStandard/Acpi.h>
+
+//
+// PCI Location of PIIX4 Power Management PCI Configuration Registers
+//
+#define PIIX4_POWER_MANAGEMENT_BUS       0x00
+#define PIIX4_POWER_MANAGEMENT_DEVICE    0x01
+#define PIIX4_POWER_MANAGEMENT_FUNCTION  0x03
+
+//
+// Macro to access PIIX4 Power Management PCI Configuration Registers
+//
+#define PIIX4_PCI_POWER_MANAGEMENT_REGISTER(Register) \
+  PCI_LIB_ADDRESS (                                   \
+    PIIX4_POWER_MANAGEMENT_BUS,                       \
+    PIIX4_POWER_MANAGEMENT_DEVICE,                    \
+    PIIX4_POWER_MANAGEMENT_FUNCTION,                  \
+    Register                                          \
+    )
+
+//
+// PIIX4 Power Management PCI Configuration Registers
+//
+#define PMBA                PIIX4_PCI_POWER_MANAGEMENT_REGISTER (0x40)
+#define   PMBA_RTE          BIT0
+#define PMREGMISC           PIIX4_PCI_POWER_MANAGEMENT_REGISTER (0x80)
+#define   PMIOSE            BIT0
+
+//
+// The ACPI Time in the PIIX4 is a 24-bit counter
+//
+#define ACPI_TIMER_COUNT_SIZE  BIT24
+
+//
+// Offset in the PIIX4 Power Management Base Address to the ACPI Timer 
+//
+#define ACPI_TIMER_OFFSET      0x8
+
+/**
+  The constructor function enables ACPI IO space.
+
+  If ACPI I/O space not enabled, this function will enable it.
+  It will always return RETURN_SUCCESS.
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+AcpiTimerLibConstructor (
+  VOID
+  )
+{
+  //
+  // Check to see if the PIIX4 Power Management Base Address is already enabled
+  //
+  if ((PciRead8 (PMREGMISC) & PMIOSE) == 0) {
+    //
+    // If the PIIX4 Power Management Base Address is not programmed, 
+    // then program the PIIX4 Power Management Base Address from a PCD.
+    //
+    PciAndThenOr32 (PMBA, (UINT32)(~0x0000FFC0), PcdGet16 (PcdAcpiPmBaseAddress));
+
+    //
+    // Enable PMBA I/O port decodes in PMREGMISC
+    //
+    PciOr8 (PMREGMISC, PMIOSE);
+  }
+  
+  return RETURN_SUCCESS;
+}
+
+/**
+  Internal function to read the current tick counter of ACPI.
+
+  Internal function to read the current tick counter of ACPI.
+
+  @return The tick counter read.
+
+**/
+UINT32
+InternalAcpiGetTimerTick (
+  VOID
+  )
+{
+  //
+  //   Read PMBA to read and return the current ACPI timer value.
+  //
+  return IoRead32 ((PciRead32 (PMBA) & ~PMBA_RTE) + ACPI_TIMER_OFFSET);
+}
+
+/**
+  Stalls the CPU for at least the given number of ticks.
+
+  Stalls the CPU for at least the given number of ticks. It's invoked by
+  MicroSecondDelay() and NanoSecondDelay().
+
+  @param  Delay     A period of time to delay in ticks.
+
+**/
+VOID
+InternalAcpiDelay (
+  IN      UINT32                    Delay
+  )
+{
+  UINT32                            Ticks;
+  UINT32                            Times;
+
+  Times    = Delay >> 22;
+  Delay   &= BIT22 - 1;
+  do {
+    //
+    // The target timer count is calculated here
+    //
+    Ticks    = InternalAcpiGetTimerTick () + Delay;
+    Delay    = BIT22;
+    //
+    // Wait until time out
+    // Delay >= 2^23 could not be handled by this function
+    // Timer wrap-arounds are handled correctly by this function
+    //
+    while (((Ticks - InternalAcpiGetTimerTick ()) & BIT23) == 0) {
+      CpuPause ();
+    }
+  } while (Times-- > 0);
+}
+
+/**
+  Stalls the CPU for at least the given number of microseconds.
+
+  Stalls the CPU for the number of microseconds specified by MicroSeconds.
+
+  @param  MicroSeconds  The minimum number of microseconds to delay.
+
+  @return MicroSeconds
+
+**/
+UINTN
+EFIAPI
+MicroSecondDelay (
+  IN      UINTN                     MicroSeconds
+  )
+{
+  InternalAcpiDelay (
+    (UINT32)DivU64x32 (
+              MultU64x32 (
+                MicroSeconds,
+                ACPI_TIMER_FREQUENCY
+                ),
+              1000000u
+              )
+    );
+  return MicroSeconds;
+}
+
+/**
+  Stalls the CPU for at least the given number of nanoseconds.
+
+  Stalls the CPU for the number of nanoseconds specified by NanoSeconds.
+
+  @param  NanoSeconds The minimum number of nanoseconds to delay.
+
+  @return NanoSeconds
+
+**/
+UINTN
+EFIAPI
+NanoSecondDelay (
+  IN      UINTN                     NanoSeconds
+  )
+{
+  InternalAcpiDelay (
+    (UINT32)DivU64x32 (
+              MultU64x32 (
+                NanoSeconds,
+                ACPI_TIMER_FREQUENCY
+                ),
+              1000000000u
+              )
+    );
+  return NanoSeconds;
+}
+
+/**
+  Retrieves the current value of a 64-bit free running performance counter.
+
+  Retrieves the current value of a 64-bit free running performance counter. The
+  counter can either count up by 1 or count down by 1. If the physical
+  performance counter counts by a larger increment, then the counter values
+  must be translated. The properties of the counter can be retrieved from
+  GetPerformanceCounterProperties().
+
+  @return The current value of the free running performance counter.
+
+**/
+UINT64
+EFIAPI
+GetPerformanceCounter (
+  VOID
+  )
+{
+  return (UINT64)InternalAcpiGetTimerTick ();
+}
+
+/**
+  Retrieves the 64-bit frequency in Hz and the range of performance counter
+  values.
+
+  If StartValue is not NULL, then the value that the performance counter starts
+  with immediately after is it rolls over is returned in StartValue. If
+  EndValue is not NULL, then the value that the performance counter end with
+  immediately before it rolls over is returned in EndValue. The 64-bit
+  frequency of the performance counter in Hz is always returned. If StartValue
+  is less than EndValue, then the performance counter counts up. If StartValue
+  is greater than EndValue, then the performance counter counts down. For
+  example, a 64-bit free running counter that counts up would have a StartValue
+  of 0 and an EndValue of 0xFFFFFFFFFFFFFFFF. A 24-bit free running counter
+  that counts down would have a StartValue of 0xFFFFFF and an EndValue of 0.
+
+  @param  StartValue  The value the performance counter starts with when it
+                      rolls over.
+  @param  EndValue    The value that the performance counter ends with before
+                      it rolls over.
+
+  @return The frequency in Hz.
+
+**/
+UINT64
+EFIAPI
+GetPerformanceCounterProperties (
+  OUT      UINT64                    *StartValue,  OPTIONAL
+  OUT      UINT64                    *EndValue     OPTIONAL
+  )
+{
+  if (StartValue != NULL) {
+    *StartValue = 0;
+  }
+
+  if (EndValue != NULL) {
+    *EndValue = ACPI_TIMER_COUNT_SIZE - 1;
+  }
+
+  return ACPI_TIMER_FREQUENCY;
+}
+
+/**
+  Converts elapsed ticks of performance counter to time in nanoseconds.
+
+  This function converts the elapsed ticks of running performance counter to
+  time value in unit of nanoseconds.
+
+  @param  Ticks     The number of elapsed ticks of running performance counter.
+
+  @return The elapsed time in nanoseconds.
+
+**/
+UINT64
+EFIAPI
+GetTimeInNanoSecond (
+  IN      UINT64                     Ticks
+  )
+{
+  UINT64  NanoSeconds;
+  UINT32  Remainder;
+
+  //
+  //          Ticks
+  // Time = --------- x 1,000,000,000
+  //        Frequency
+  //
+  NanoSeconds = MultU64x32 (DivU64x32Remainder (Ticks, ACPI_TIMER_FREQUENCY, &Remainder), 1000000000u);
+
+  //
+  // Frequency < 0x100000000, so Remainder < 0x100000000, then (Remainder * 1,000,000,000)
+  // will not overflow 64-bit.
+  //
+  NanoSeconds += DivU64x32 (MultU64x32 ((UINT64) Remainder, 1000000000u), ACPI_TIMER_FREQUENCY);
+
+  return NanoSeconds;
+}
diff --git a/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf b/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
new file mode 100644
index 0000000..78c1569
--- /dev/null
+++ b/corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
@@ -0,0 +1,44 @@
+## @file
+#  ACPI Timer Library Instance.
+#
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = AcpiTimerLib
+  FILE_GUID                      = CDD9D74F-213E-4c28-98F7-8B4A167DB936
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = TimerLib
+
+  CONSTRUCTOR                    = AcpiTimerLibConstructor
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  AcpiTimerLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  corebootPkg/corebootPkg.dec
+
+[Pcd]
+  gUefiCorebootPkgTokenSpaceGuid.PcdAcpiPmBaseAddress
+
+[LibraryClasses]
+  BaseLib
+  PciLib
+  IoLib
diff --git a/corebootPkg/Library/PlatformBdsLib/BdsPlatform.c b/corebootPkg/Library/PlatformBdsLib/BdsPlatform.c
new file mode 100644
index 0000000..f65991c
--- /dev/null
+++ b/corebootPkg/Library/PlatformBdsLib/BdsPlatform.c
@@ -0,0 +1,1301 @@
+/** @file
+  Platform BDS customizations.
+
+  Copyright (c) 2004 - 2012, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "BdsPlatform.h"
+
+
+//
+// Global data
+//
+
+VOID          *mEfiDevPathNotifyReg;
+EFI_EVENT     mEfiDevPathEvent;
+BOOLEAN       mDetectVgaOnly;
+
+
+//
+// Type definitions
+//
+
+typedef
+EFI_STATUS
+(EFIAPI *PROTOCOL_INSTANCE_CALLBACK)(
+  IN EFI_HANDLE           Handle,
+  IN VOID                 *Instance,
+  IN VOID                 *Context
+  );
+
+/**
+  @param[in]  Handle - Handle of PCI device instance
+  @param[in]  PciIo - PCI IO protocol instance
+  @param[in]  Pci - PCI Header register block
+**/
+typedef
+EFI_STATUS
+(EFIAPI *VISIT_PCI_INSTANCE_CALLBACK)(
+  IN EFI_HANDLE           Handle,
+  IN EFI_PCI_IO_PROTOCOL  *PciIo,
+  IN PCI_TYPE00           *Pci
+  );
+
+
+//
+// Function prototypes
+//
+
+EFI_STATUS
+VisitAllInstancesOfProtocol (
+  IN EFI_GUID                    *Id,
+  IN PROTOCOL_INSTANCE_CALLBACK  CallBackFunction,
+  IN VOID                        *Context
+  );
+
+EFI_STATUS
+VisitAllPciInstancesOfProtocol (
+  IN VISIT_PCI_INSTANCE_CALLBACK CallBackFunction
+  );
+
+VOID
+InstallDevicePathCallback (
+  VOID
+  );
+
+//
+// BDS Platform Functions
+//
+VOID
+EFIAPI
+PlatformBdsInit (
+  VOID
+  )
+/*++
+
+Routine Description:
+
+  Platform Bds init. Incude the platform firmware vendor, revision
+  and so crc check.
+
+Arguments:
+
+Returns:
+
+  None.
+
+--*/
+{
+  DEBUG ((EFI_D_INFO, "PlatformBdsInit\n"));
+  InstallDevicePathCallback ();
+}
+
+
+EFI_STATUS
+ConnectRootBridge (
+  VOID
+  )
+/*++
+
+Routine Description:
+
+  Connect RootBridge
+
+Arguments:
+
+  None.
+
+Returns:
+
+  EFI_SUCCESS             - Connect RootBridge successfully.
+  EFI_STATUS              - Connect RootBridge fail.
+
+--*/
+{
+  EFI_STATUS                Status;
+  EFI_HANDLE                RootHandle;
+
+  //
+  // Make all the PCI_IO protocols on PCI Seg 0 show up
+  //
+  BdsLibConnectDevicePath (gPlatformRootBridges[0]);
+
+  Status = gBS->LocateDevicePath (
+                  &gEfiDevicePathProtocolGuid,
+                  &gPlatformRootBridges[0],
+                  &RootHandle
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  Status = gBS->ConnectController (RootHandle, NULL, NULL, FALSE);
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+EFI_STATUS
+PrepareLpcBridgeDevicePath (
+  IN EFI_HANDLE                DeviceHandle
+  )
+/*++
+
+Routine Description:
+
+  Add IsaKeyboard to ConIn,
+  add IsaSerial to ConOut, ConIn, ErrOut.
+  LPC Bridge: 06 01 00
+
+Arguments:
+
+  DeviceHandle            - Handle of PCIIO protocol.
+
+Returns:
+
+  EFI_SUCCESS             - LPC bridge is added to ConOut, ConIn, and ErrOut.
+  EFI_STATUS              - No LPC bridge is added.
+
+--*/
+{
+  EFI_STATUS                Status;
+  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;
+  EFI_DEVICE_PATH_PROTOCOL  *TempDevicePath;
+  CHAR16                    *DevPathStr;
+
+  DevicePath = NULL;
+  Status = gBS->HandleProtocol (
+                  DeviceHandle,
+                  &gEfiDevicePathProtocolGuid,
+                  (VOID*)&DevicePath
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  TempDevicePath = DevicePath;
+
+  //
+  // Register Keyboard
+  //
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gPnpPs2KeyboardDeviceNode);
+
+  BdsLibUpdateConsoleVariable (VarConsoleInp, DevicePath, NULL);
+
+  //
+  // Register COM1
+  //
+  DevicePath = TempDevicePath;
+  gPnp16550ComPortDeviceNode.UID = 0;
+
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gPnp16550ComPortDeviceNode);
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gUartDeviceNode);
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gTerminalTypeDeviceNode);
+
+  //
+  // Print Device Path
+  //
+  DevPathStr = DevicePathToStr(DevicePath);
+  DEBUG((
+    EFI_D_INFO,
+    "BdsPlatform.c+%d: COM%d DevPath: %s\n",
+    __LINE__,
+    gPnp16550ComPortDeviceNode.UID + 1,
+    DevPathStr
+    ));
+  FreePool(DevPathStr);
+
+  BdsLibUpdateConsoleVariable (VarConsoleOut, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarConsoleInp, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarErrorOut, DevicePath, NULL);
+
+  //
+  // Register COM2
+  //
+  DevicePath = TempDevicePath;
+  gPnp16550ComPortDeviceNode.UID = 1;
+
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gPnp16550ComPortDeviceNode);
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gUartDeviceNode);
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gTerminalTypeDeviceNode);
+
+  //
+  // Print Device Path
+  //
+  DevPathStr = DevicePathToStr(DevicePath);
+  DEBUG((
+    EFI_D_INFO,
+    "BdsPlatform.c+%d: COM%d DevPath: %s\n",
+    __LINE__,
+    gPnp16550ComPortDeviceNode.UID + 1,
+    DevPathStr
+    ));
+  FreePool(DevPathStr);
+
+  BdsLibUpdateConsoleVariable (VarConsoleOut, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarConsoleInp, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarErrorOut, DevicePath, NULL);
+
+  return EFI_SUCCESS;
+}
+
+EFI_STATUS
+GetGopDevicePath (
+   IN  EFI_DEVICE_PATH_PROTOCOL *PciDevicePath,
+   OUT EFI_DEVICE_PATH_PROTOCOL **GopDevicePath
+   )
+{
+  UINTN                           Index;
+  EFI_STATUS                      Status;
+  EFI_HANDLE                      PciDeviceHandle;
+  EFI_DEVICE_PATH_PROTOCOL        *TempDevicePath;
+  EFI_DEVICE_PATH_PROTOCOL        *TempPciDevicePath;
+  UINTN                           GopHandleCount;
+  EFI_HANDLE                      *GopHandleBuffer;
+
+  if (PciDevicePath == NULL || GopDevicePath == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Initialize the GopDevicePath to be PciDevicePath
+  //
+  *GopDevicePath    = PciDevicePath;
+  TempPciDevicePath = PciDevicePath;
+
+  Status = gBS->LocateDevicePath (
+                  &gEfiDevicePathProtocolGuid,
+                  &TempPciDevicePath,
+                  &PciDeviceHandle
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Try to connect this handle, so that GOP dirver could start on this
+  // device and create child handles with GraphicsOutput Protocol installed
+  // on them, then we get device paths of these child handles and select
+  // them as possible console device.
+  //
+  gBS->ConnectController (PciDeviceHandle, NULL, NULL, FALSE);
+
+  Status = gBS->LocateHandleBuffer (
+                  ByProtocol,
+                  &gEfiGraphicsOutputProtocolGuid,
+                  NULL,
+                  &GopHandleCount,
+                  &GopHandleBuffer
+                  );
+  if (!EFI_ERROR (Status)) {
+    //
+    // Add all the child handles as possible Console Device
+    //
+    for (Index = 0; Index < GopHandleCount; Index++) {
+      Status = gBS->HandleProtocol (GopHandleBuffer[Index], &gEfiDevicePathProtocolGuid, (VOID*)&TempDevicePath);
+      if (EFI_ERROR (Status)) {
+        continue;
+      }
+      if (CompareMem (
+            PciDevicePath,
+            TempDevicePath,
+            GetDevicePathSize (PciDevicePath) - END_DEVICE_PATH_LENGTH
+            ) == 0) {
+        //
+        // In current implementation, we only enable one of the child handles
+        // as console device, i.e. sotre one of the child handle's device
+        // path to variable "ConOut"
+        // In futhure, we could select all child handles to be console device
+        //
+
+        *GopDevicePath = TempDevicePath;
+
+        //
+        // Delete the PCI device's path that added by GetPlugInPciVgaDevicePath()
+        // Add the integrity GOP device path.
+        //
+        BdsLibUpdateConsoleVariable (VarConsoleOutDev, NULL, PciDevicePath);
+        BdsLibUpdateConsoleVariable (VarConsoleOutDev, TempDevicePath, NULL);
+      }
+    }
+    gBS->FreePool (GopHandleBuffer);
+  }
+
+  return EFI_SUCCESS;
+}
+
+EFI_STATUS
+PreparePciVgaDevicePath (
+  IN EFI_HANDLE                DeviceHandle
+  )
+/*++
+
+Routine Description:
+
+  Add PCI VGA to ConOut.
+  PCI VGA: 03 00 00
+
+Arguments:
+
+  DeviceHandle            - Handle of PCIIO protocol.
+
+Returns:
+
+  EFI_SUCCESS             - PCI VGA is added to ConOut.
+  EFI_STATUS              - No PCI VGA device is added.
+
+--*/
+{
+  EFI_STATUS                Status;
+  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;
+  EFI_DEVICE_PATH_PROTOCOL  *GopDevicePath;
+
+  DevicePath = NULL;
+  Status = gBS->HandleProtocol (
+                  DeviceHandle,
+                  &gEfiDevicePathProtocolGuid,
+                  (VOID*)&DevicePath
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  GetGopDevicePath (DevicePath, &GopDevicePath);
+  DevicePath = GopDevicePath;
+
+  BdsLibUpdateConsoleVariable (VarConsoleOut, DevicePath, NULL);
+
+  return EFI_SUCCESS;
+}
+
+EFI_STATUS
+PreparePciSerialDevicePath (
+  IN EFI_HANDLE                DeviceHandle
+  )
+/*++
+
+Routine Description:
+
+  Add PCI Serial to ConOut, ConIn, ErrOut.
+  PCI Serial: 07 00 02
+
+Arguments:
+
+  DeviceHandle            - Handle of PCIIO protocol.
+
+Returns:
+
+  EFI_SUCCESS             - PCI Serial is added to ConOut, ConIn, and ErrOut.
+  EFI_STATUS              - No PCI Serial device is added.
+
+--*/
+{
+  EFI_STATUS                Status;
+  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;
+
+  DevicePath = NULL;
+  Status = gBS->HandleProtocol (
+                  DeviceHandle,
+                  &gEfiDevicePathProtocolGuid,
+                  (VOID*)&DevicePath
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gUartDeviceNode);
+  DevicePath = AppendDevicePathNode (DevicePath, (EFI_DEVICE_PATH_PROTOCOL *)&gTerminalTypeDeviceNode);
+
+  BdsLibUpdateConsoleVariable (VarConsoleOut, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarConsoleInp, DevicePath, NULL);
+  BdsLibUpdateConsoleVariable (VarErrorOut, DevicePath, NULL);
+
+  return EFI_SUCCESS;
+}
+
+EFI_STATUS
+VisitAllInstancesOfProtocol (
+  IN EFI_GUID                    *Id,
+  IN PROTOCOL_INSTANCE_CALLBACK  CallBackFunction,
+  IN VOID                        *Context
+  )
+{
+  EFI_STATUS                Status;
+  UINTN                     HandleCount;
+  EFI_HANDLE                *HandleBuffer;
+  UINTN                     Index;
+  VOID                      *Instance;
+
+  //
+  // Start to check all the PciIo to find all possible device
+  //
+  HandleCount = 0;
+  HandleBuffer = NULL;
+  Status = gBS->LocateHandleBuffer (
+                  ByProtocol,
+                  Id,
+                  NULL,
+                  &HandleCount,
+                  &HandleBuffer
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  for (Index = 0; Index < HandleCount; Index++) {
+    Status = gBS->HandleProtocol (HandleBuffer[Index], Id, &Instance);
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    Status = (*CallBackFunction) (
+               HandleBuffer[Index],
+               Instance,
+               Context
+               );
+  }
+
+  gBS->FreePool (HandleBuffer);
+
+  return EFI_SUCCESS;
+}
+
+
+EFI_STATUS
+EFIAPI
+VisitingAPciInstance (
+  IN EFI_HANDLE  Handle,
+  IN VOID        *Instance,
+  IN VOID        *Context
+  )
+{
+  EFI_STATUS                Status;
+  EFI_PCI_IO_PROTOCOL       *PciIo;
+  PCI_TYPE00                Pci;
+
+  PciIo = (EFI_PCI_IO_PROTOCOL*) Instance;
+
+  //
+  // Check for all PCI device
+  //
+  Status = PciIo->Pci.Read (
+                    PciIo,
+                    EfiPciIoWidthUint32,
+                    0,
+                    sizeof (Pci) / sizeof (UINT32),
+                    &Pci
+                    );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  return (*(VISIT_PCI_INSTANCE_CALLBACK)(UINTN) Context) (
+           Handle,
+           PciIo,
+           &Pci
+           );
+
+}
+
+
+
+EFI_STATUS
+VisitAllPciInstances (
+  IN VISIT_PCI_INSTANCE_CALLBACK CallBackFunction
+  )
+{
+  return VisitAllInstancesOfProtocol (
+           &gEfiPciIoProtocolGuid,
+           VisitingAPciInstance,
+           (VOID*)(UINTN) CallBackFunction
+           );
+}
+
+
+/**
+  Do platform specific PCI Device check and add them to
+  ConOut, ConIn, ErrOut.
+
+  @param[in]  Handle - Handle of PCI device instance
+  @param[in]  PciIo - PCI IO protocol instance
+  @param[in]  Pci - PCI Header register block
+
+  @retval EFI_SUCCESS - PCI Device check and Console variable update successfully.
+  @retval EFI_STATUS - PCI Device check or Console variable update fail.
+
+**/
+EFI_STATUS
+EFIAPI
+DetectAndPreparePlatformPciDevicePath (
+  IN EFI_HANDLE           Handle,
+  IN EFI_PCI_IO_PROTOCOL  *PciIo,
+  IN PCI_TYPE00           *Pci
+  )
+{
+  EFI_STATUS                Status;
+
+  Status = PciIo->Attributes (
+    PciIo,
+    EfiPciIoAttributeOperationEnable,
+    EFI_PCI_DEVICE_ENABLE,
+    NULL
+    );
+  ASSERT_EFI_ERROR (Status);
+
+  if (!mDetectVgaOnly) {
+    //
+    // Here we decide whether it is LPC Bridge
+    //
+    if ((IS_PCI_LPC (Pci)) ||
+        ((IS_PCI_ISA_PDECODE (Pci)) &&
+         (Pci->Hdr.VendorId == 0x8086) &&
+         (Pci->Hdr.DeviceId == 0x7000)
+        )
+       ) {
+      //
+      // Add IsaKeyboard to ConIn,
+      // add IsaSerial to ConOut, ConIn, ErrOut
+      //
+      DEBUG ((EFI_D_INFO, "Found LPC Bridge device\n"));
+      PrepareLpcBridgeDevicePath (Handle);
+      return EFI_SUCCESS;
+    }
+    //
+    // Here we decide which Serial device to enable in PCI bus
+    //
+    if (IS_PCI_16550SERIAL (Pci)) {
+      //
+      // Add them to ConOut, ConIn, ErrOut.
+      //
+      DEBUG ((EFI_D_INFO, "Found PCI 16550 SERIAL device\n"));
+      PreparePciSerialDevicePath (Handle);
+      return EFI_SUCCESS;
+    }
+  }
+
+  //
+  // Here we decide which VGA device to enable in PCI bus
+  //
+  if (IS_PCI_VGA (Pci)) {
+    //
+    // Add them to ConOut.
+    //
+    DEBUG ((EFI_D_INFO, "Found PCI VGA device\n"));
+    PreparePciVgaDevicePath (Handle);
+    return EFI_SUCCESS;
+  }
+
+  return Status;
+}
+
+
+/**
+  Do platform specific PCI Device check and add them to ConOut, ConIn, ErrOut
+
+  @param[in]  DetectVgaOnly - Only detect VGA device if it's TRUE.
+
+  @retval EFI_SUCCESS - PCI Device check and Console variable update successfully.
+  @retval EFI_STATUS - PCI Device check or Console variable update fail.
+
+**/
+EFI_STATUS
+DetectAndPreparePlatformPciDevicePaths (
+  BOOLEAN DetectVgaOnly
+  )
+{
+  mDetectVgaOnly = DetectVgaOnly;
+  return VisitAllPciInstances (DetectAndPreparePlatformPciDevicePath);
+}
+
+
+EFI_STATUS
+PlatformBdsConnectConsole (
+  IN BDS_CONSOLE_CONNECT_ENTRY   *PlatformConsole
+  )
+/*++
+
+Routine Description:
+
+  Connect the predefined platform default console device. Always try to find
+  and enable the vga device if have.
+
+Arguments:
+
+  PlatformConsole         - Predfined platform default console device array.
+
+Returns:
+
+  EFI_SUCCESS             - Success connect at least one ConIn and ConOut
+                            device, there must have one ConOut device is
+                            active vga device.
+
+  EFI_STATUS              - Return the status of
+                            BdsLibConnectAllDefaultConsoles ()
+
+--*/
+{
+  EFI_STATUS                         Status;
+  UINTN                              Index;
+  EFI_DEVICE_PATH_PROTOCOL           *VarConout;
+  EFI_DEVICE_PATH_PROTOCOL           *VarConin;
+  UINTN                              DevicePathSize;
+
+  //
+  // Connect RootBridge
+  //
+  VarConout = BdsLibGetVariableAndSize (
+                VarConsoleOut,
+                &gEfiGlobalVariableGuid,
+                &DevicePathSize
+                );
+  VarConin = BdsLibGetVariableAndSize (
+               VarConsoleInp,
+               &gEfiGlobalVariableGuid,
+               &DevicePathSize
+               );
+
+  if (VarConout == NULL || VarConin == NULL) {
+    //
+    // Do platform specific PCI Device check and add them to ConOut, ConIn, ErrOut
+    //
+    DetectAndPreparePlatformPciDevicePaths (FALSE);
+
+    //
+    // Have chance to connect the platform default console,
+    // the platform default console is the minimue device group
+    // the platform should support
+    //
+    for (Index = 0; PlatformConsole[Index].DevicePath != NULL; ++Index) {
+      //
+      // Update the console variable with the connect type
+      //
+      if ((PlatformConsole[Index].ConnectType & CONSOLE_IN) == CONSOLE_IN) {
+        BdsLibUpdateConsoleVariable (VarConsoleInp, PlatformConsole[Index].DevicePath, NULL);
+      }
+      if ((PlatformConsole[Index].ConnectType & CONSOLE_OUT) == CONSOLE_OUT) {
+        BdsLibUpdateConsoleVariable (VarConsoleOut, PlatformConsole[Index].DevicePath, NULL);
+      }
+      if ((PlatformConsole[Index].ConnectType & STD_ERROR) == STD_ERROR) {
+        BdsLibUpdateConsoleVariable (VarErrorOut, PlatformConsole[Index].DevicePath, NULL);
+      }
+    }
+  } else {
+    //
+    // Only detect VGA device and add them to ConOut
+    //
+    DetectAndPreparePlatformPciDevicePaths (TRUE);
+  }
+
+  //
+  // Connect the all the default console with current cosole variable
+  //
+  Status = BdsLibConnectAllDefaultConsoles ();
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+EFI_STATUS
+EFIAPI
+ConnectRecursivelyIfPciMassStorage (
+  IN EFI_HANDLE           Handle,
+  IN EFI_PCI_IO_PROTOCOL  *Instance,
+  IN PCI_TYPE00           *PciHeader
+  )
+{
+  EFI_STATUS                Status;
+  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;
+  CHAR16                    *DevPathStr;
+
+  if (IS_CLASS1 (PciHeader, PCI_CLASS_MASS_STORAGE)) {
+    DevicePath = NULL;
+    Status = gBS->HandleProtocol (
+                    Handle,
+                    &gEfiDevicePathProtocolGuid,
+                    (VOID*)&DevicePath
+                    );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    //
+    // Print Device Path
+    //
+    DevPathStr = DevicePathToStr (DevicePath);
+    DEBUG((
+      EFI_D_INFO,
+      "Found Mass Storage device: %s\n",
+      DevPathStr
+      ));
+    FreePool(DevPathStr);
+
+    Status = gBS->ConnectController (Handle, NULL, NULL, TRUE);
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+  }
+
+  return EFI_SUCCESS;
+}
+
+VOID
+PlatformBdsConnectSequence (
+  VOID
+  )
+/*++
+
+Routine Description:
+
+  Connect with predeined platform connect sequence,
+  the OEM/IBV can customize with their own connect sequence.
+
+Arguments:
+
+  None.
+
+Returns:
+
+  None.
+
+--*/
+{
+  UINTN Index;
+
+  DEBUG ((EFI_D_INFO, "PlatformBdsConnectSequence\n"));
+
+  Index = 0;
+
+  //
+  // Here we can get the customized platform connect sequence
+  // Notes: we can connect with new variable which record the
+  // last time boots connect device path sequence
+  //
+  while (gPlatformConnectSequence[Index] != NULL) {
+    //
+    // Build the platform boot option
+    //
+    BdsLibConnectDevicePath (gPlatformConnectSequence[Index]);
+    Index++;
+  }
+
+  //
+  // Just use the simple policy to connect all devices
+  //
+  BdsLibConnectAll ();
+
+  //
+  // Clear the logo after all devices are connected.
+  //
+  gST->ConOut->ClearScreen (gST->ConOut);
+}
+
+VOID
+PlatformBdsGetDriverOption (
+  IN OUT LIST_ENTRY              *BdsDriverLists
+  )
+/*++
+
+Routine Description:
+
+  Load the predefined driver option, OEM/IBV can customize this
+  to load their own drivers
+
+Arguments:
+
+  BdsDriverLists  - The header of the driver option link list.
+
+Returns:
+
+  None.
+
+--*/
+{
+  DEBUG ((EFI_D_INFO, "PlatformBdsGetDriverOption\n"));
+  return;
+}
+
+VOID
+PlatformBdsDiagnostics (
+  IN EXTENDMEM_COVERAGE_LEVEL    MemoryTestLevel,
+  IN BOOLEAN                     QuietBoot,
+  IN BASEM_MEMORY_TEST           BaseMemoryTest
+  )
+/*++
+
+Routine Description:
+
+  Perform the platform diagnostic, such like test memory. OEM/IBV also
+  can customize this fuction to support specific platform diagnostic.
+
+Arguments:
+
+  MemoryTestLevel  - The memory test intensive level
+
+  QuietBoot        - Indicate if need to enable the quiet boot
+
+  BaseMemoryTest   - A pointer to BaseMemoryTest()
+
+Returns:
+
+  None.
+
+--*/
+{
+  EFI_STATUS  Status;
+
+  DEBUG ((EFI_D_INFO, "PlatformBdsDiagnostics\n"));
+
+  //
+  // Here we can decide if we need to show
+  // the diagnostics screen
+  // Notes: this quiet boot code should be remove
+  // from the graphic lib
+  //
+  if (QuietBoot) {
+    EnableQuietBoot (PcdGetPtr(PcdLogoFile));
+    //
+    // Perform system diagnostic
+    //
+    Status = BaseMemoryTest (MemoryTestLevel);
+    if (EFI_ERROR (Status)) {
+      DisableQuietBoot ();
+    }
+
+    return ;
+  }
+  //
+  // Perform system diagnostic
+  //
+  Status = BaseMemoryTest (MemoryTestLevel);
+}
+
+
+VOID
+EFIAPI
+PlatformBdsPolicyBehavior (
+  IN OUT LIST_ENTRY                  *DriverOptionList,
+  IN OUT LIST_ENTRY                  *BootOptionList,
+  IN PROCESS_CAPSULES                ProcessCapsules,
+  IN BASEM_MEMORY_TEST               BaseMemoryTest
+  )
+/*++
+
+Routine Description:
+
+  The function will excute with as the platform policy, current policy
+  is driven by boot mode. IBV/OEM can customize this code for their specific
+  policy action.
+
+Arguments:
+
+  DriverOptionList - The header of the driver option link list
+
+  BootOptionList   - The header of the boot option link list
+
+  ProcessCapsules  - A pointer to ProcessCapsules()
+
+  BaseMemoryTest   - A pointer to BaseMemoryTest()
+
+Returns:
+
+  None.
+
+--*/
+{
+  EFI_STATUS                         Status;
+  UINT16                             Timeout;
+  EFI_EVENT                          UserInputDurationTime;
+  LIST_ENTRY                     *Link;
+  BDS_COMMON_OPTION                  *BootOption;
+  UINTN                              Index;
+  EFI_INPUT_KEY                      Key;
+  EFI_TPL                            OldTpl;
+  EFI_BOOT_MODE                      BootMode;
+
+  DEBUG ((EFI_D_INFO, "PlatformBdsPolicyBehavior\n"));
+
+  ConnectRootBridge ();
+
+  //
+  // Init the time out value
+  //
+  Timeout = PcdGet16 (PcdPlatformBootTimeOut);
+
+  //
+  // Load the driver option as the driver option list
+  //
+  PlatformBdsGetDriverOption (DriverOptionList);
+
+  //
+  // Get current Boot Mode
+  //
+  Status = BdsLibGetBootMode (&BootMode);
+  DEBUG ((EFI_D_ERROR, "Boot Mode:%x\n", BootMode));
+
+  //
+  // Go the different platform policy with different boot mode
+  // Notes: this part code can be change with the table policy
+  //
+  ASSERT (BootMode == BOOT_WITH_FULL_CONFIGURATION);
+  //
+  // Connect platform console
+  //
+  Status = PlatformBdsConnectConsole (gPlatformConsole);
+  if (EFI_ERROR (Status)) {
+    //
+    // Here OEM/IBV can customize with defined action
+    //
+    PlatformBdsNoConsoleAction ();
+  }
+  //
+  // Create a 300ms duration event to ensure user has enough input time to enter Setup
+  //
+  Status = gBS->CreateEvent (
+                  EVT_TIMER,
+                  0,
+                  NULL,
+                  NULL,
+                  &UserInputDurationTime
+                  );
+  ASSERT (Status == EFI_SUCCESS);
+  Status = gBS->SetTimer (UserInputDurationTime, TimerRelative, 3000000);
+  ASSERT (Status == EFI_SUCCESS);
+  //
+  // Memory test and Logo show
+  //
+  PlatformBdsDiagnostics (IGNORE, TRUE, BaseMemoryTest);
+
+  //
+  // Perform some platform specific connect sequence
+  //
+  PlatformBdsConnectSequence ();
+
+  //
+  // Give one chance to enter the setup if we
+  // have the time out
+  //
+  if (Timeout != 0) {
+    //PlatformBdsEnterFrontPage (Timeout, FALSE);
+  }
+
+  DEBUG ((EFI_D_INFO, "BdsLibConnectAll\n"));
+  BdsLibConnectAll ();
+  BdsLibEnumerateAllBootOption (BootOptionList);
+
+  //
+  // Please uncomment above ConnectAll and EnumerateAll code and remove following first boot
+  // checking code in real production tip.
+  //
+  // In BOOT_WITH_FULL_CONFIGURATION boot mode, should always connect every device
+  // and do enumerate all the default boot options. But in development system board, the boot mode
+  // cannot be BOOT_ASSUMING_NO_CONFIGURATION_CHANGES because the machine box
+  // is always open. So the following code only do the ConnectAll and EnumerateAll at first boot.
+  //
+  Status = BdsLibBuildOptionFromVar (BootOptionList, L"BootOrder");
+  if (EFI_ERROR(Status)) {
+    //
+    // If cannot find "BootOrder" variable,  it may be first boot.
+    // Try to connect all devices and enumerate all boot options here.
+    //
+    BdsLibConnectAll ();
+    BdsLibEnumerateAllBootOption (BootOptionList);
+  }
+
+  //
+  // To give the User a chance to enter Setup here, if user set TimeOut is 0.
+  // BDS should still give user a chance to enter Setup
+  //
+  // Connect first boot option, and then check user input before exit
+  //
+  for (Link = BootOptionList->ForwardLink; Link != BootOptionList;Link = Link->ForwardLink) {
+    BootOption = CR (Link, BDS_COMMON_OPTION, Link, BDS_LOAD_OPTION_SIGNATURE);
+    if (!IS_LOAD_OPTION_TYPE (BootOption->Attribute, LOAD_OPTION_ACTIVE)) {
+      //
+      // skip the header of the link list, becuase it has no boot option
+      //
+      continue;
+    } else {
+      //
+      // Make sure the boot option device path connected, but ignore the BBS device path
+      //
+      if (DevicePathType (BootOption->DevicePath) != BBS_DEVICE_PATH) {
+        BdsLibConnectDevicePath (BootOption->DevicePath);
+      }
+      break;
+    }
+  }
+
+  //
+  // Check whether the user input after the duration time has expired
+  //
+  OldTpl = EfiGetCurrentTpl();
+  gBS->RestoreTPL (TPL_APPLICATION);
+  gBS->WaitForEvent (1, &UserInputDurationTime, &Index);
+  gBS->CloseEvent (UserInputDurationTime);
+  Status = gST->ConIn->ReadKeyStroke (gST->ConIn, &Key);
+  gBS->RaiseTPL (OldTpl);
+
+  if (!EFI_ERROR (Status)) {
+    //
+    // Enter Setup if user input
+    //
+    Timeout = 0xffff;
+    PlatformBdsEnterFrontPage (Timeout, FALSE);
+  }
+
+  return ;
+}
+
+VOID
+EFIAPI
+PlatformBdsBootSuccess (
+  IN  BDS_COMMON_OPTION   *Option
+  )
+/*++
+
+Routine Description:
+
+  Hook point after a boot attempt succeeds. We don't expect a boot option to
+  return, so the EFI 1.0 specification defines that you will default to an
+  interactive mode and stop processing the BootOrder list in this case. This
+  is alos a platform implementation and can be customized by IBV/OEM.
+
+Arguments:
+
+  Option - Pointer to Boot Option that succeeded to boot.
+
+Returns:
+
+  None.
+
+--*/
+{
+  CHAR16  *TmpStr;
+
+  DEBUG ((EFI_D_INFO, "PlatformBdsBootSuccess\n"));
+  //
+  // If Boot returned with EFI_SUCCESS and there is not in the boot device
+  // select loop then we need to pop up a UI and wait for user input.
+  //
+  TmpStr = Option->StatusString;
+  if (TmpStr != NULL) {
+    BdsLibOutputStrings (gST->ConOut, TmpStr, Option->Description, L"\n\r", NULL);
+    FreePool (TmpStr);
+  }
+}
+
+VOID
+EFIAPI
+PlatformBdsBootFail (
+  IN  BDS_COMMON_OPTION  *Option,
+  IN  EFI_STATUS         Status,
+  IN  CHAR16             *ExitData,
+  IN  UINTN              ExitDataSize
+  )
+/*++
+
+Routine Description:
+
+  Hook point after a boot attempt fails.
+
+Arguments:
+
+  Option - Pointer to Boot Option that failed to boot.
+
+  Status - Status returned from failed boot.
+
+  ExitData - Exit data returned from failed boot.
+
+  ExitDataSize - Exit data size returned from failed boot.
+
+Returns:
+
+  None.
+
+--*/
+{
+  CHAR16  *TmpStr;
+
+  DEBUG ((EFI_D_INFO, "PlatformBdsBootFail\n"));
+
+  //
+  // If Boot returned with failed status then we need to pop up a UI and wait
+  // for user input.
+  //
+  TmpStr = Option->StatusString;
+  if (TmpStr != NULL) {
+    BdsLibOutputStrings (gST->ConOut, TmpStr, Option->Description, L"\n\r", NULL);
+    FreePool (TmpStr);
+  }
+}
+
+EFI_STATUS
+PlatformBdsNoConsoleAction (
+  VOID
+  )
+/*++
+
+Routine Description:
+
+  This function is remained for IBV/OEM to do some platform action,
+  if there no console device can be connected.
+
+Arguments:
+
+  None.
+
+Returns:
+
+  EFI_SUCCESS      - Direct return success now.
+
+--*/
+{
+  DEBUG ((EFI_D_INFO, "PlatformBdsNoConsoleAction\n"));
+  return EFI_SUCCESS;
+}
+
+VOID
+EFIAPI
+PlatformBdsLockNonUpdatableFlash (
+  VOID
+  )
+{
+  DEBUG ((EFI_D_INFO, "PlatformBdsLockNonUpdatableFlash\n"));
+  return;
+}
+
+
+/**
+  This notification function is invoked when an instance of the
+  EFI_DEVICE_PATH_PROTOCOL is produced.
+
+  @param  Event                 The event that occured
+  @param  Context               For EFI compatiblity.  Not used.
+
+**/
+VOID
+EFIAPI
+NotifyDevPath (
+  IN  EFI_EVENT Event,
+  IN  VOID      *Context
+  )
+{
+  EFI_HANDLE                            Handle;
+  EFI_STATUS                            Status;
+  UINTN                                 BufferSize;
+  EFI_DEVICE_PATH_PROTOCOL             *DevPathNode;
+  ATAPI_DEVICE_PATH                    *Atapi;
+
+  //
+  // Examine all new handles
+  //
+  for (;;) {
+    //
+    // Get the next handle
+    //
+    BufferSize = sizeof (Handle);
+    Status = gBS->LocateHandle (
+              ByRegisterNotify,
+              NULL,
+              mEfiDevPathNotifyReg,
+              &BufferSize,
+              &Handle
+              );
+
+    //
+    // If not found, we're done
+    //
+    if (EFI_NOT_FOUND == Status) {
+      break;
+    }
+
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    //
+    // Get the DevicePath protocol on that handle
+    //
+    Status = gBS->HandleProtocol (Handle, &gEfiDevicePathProtocolGuid, (VOID **)&DevPathNode);
+    ASSERT_EFI_ERROR (Status);
+
+    while (!IsDevicePathEnd (DevPathNode)) {
+      //
+      // Find the handler to dump this device path node
+      //
+      if (
+           (DevicePathType(DevPathNode) == MESSAGING_DEVICE_PATH) &&
+           (DevicePathSubType(DevPathNode) == MSG_ATAPI_DP)
+         ) {
+        Atapi = (ATAPI_DEVICE_PATH*) DevPathNode;
+        PciOr16 (
+          PCI_LIB_ADDRESS (
+            0,
+            1,
+            1,
+            (Atapi->PrimarySecondary == 1) ? 0x42: 0x40
+            ),
+          BIT15
+          );
+      }
+
+      //
+      // Next device path node
+      //
+      DevPathNode = NextDevicePathNode (DevPathNode);
+    }
+  }
+
+  return;
+}
+
+
+VOID
+InstallDevicePathCallback (
+  VOID
+  )
+{
+  DEBUG ((EFI_D_INFO, "Registered NotifyDevPath Event\n"));
+  mEfiDevPathEvent = EfiCreateProtocolNotifyEvent (
+                          &gEfiDevicePathProtocolGuid,
+                          TPL_CALLBACK,
+                          NotifyDevPath,
+                          NULL,
+                          &mEfiDevPathNotifyReg
+                          );
+}
+
+/**
+  Lock the ConsoleIn device in system table. All key
+  presses will be ignored until the Password is typed in. The only way to
+  disable the password is to type it in to a ConIn device.
+
+  @param  Password        Password used to lock ConIn device.
+
+  @retval EFI_SUCCESS     lock the Console In Spliter virtual handle successfully.
+  @retval EFI_UNSUPPORTED Password not found
+
+**/
+EFI_STATUS
+EFIAPI
+LockKeyboards (
+  IN  CHAR16    *Password
+  )
+{
+    return EFI_UNSUPPORTED;
+}
+
diff --git a/corebootPkg/Library/PlatformBdsLib/BdsPlatform.h b/corebootPkg/Library/PlatformBdsLib/BdsPlatform.h
new file mode 100644
index 0000000..c3c9fe0
--- /dev/null
+++ b/corebootPkg/Library/PlatformBdsLib/BdsPlatform.h
@@ -0,0 +1,308 @@
+/** @file
+  Platform BDS customizations include file.
+
+  Copyright (c) 2006 - 2007, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+Module Name:
+
+  BdsPlatform.h
+
+Abstract:
+
+  Head file for BDS Platform specific code
+
+**/
+
+#ifndef _PLATFORM_SPECIFIC_BDS_PLATFORM_H_
+#define _PLATFORM_SPECIFIC_BDS_PLATFORM_H_
+
+
+#include <PiDxe.h>
+
+#include <IndustryStandard/Pci.h>
+#include <IndustryStandard/Acpi.h>
+#include <IndustryStandard/SmBios.h>
+#include <IndustryStandard/PeImage.h>
+
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/BaseLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PciLib.h>
+#include <Library/GenericBdsLib.h>
+#include <Library/PlatformBdsLib.h>
+#include <Library/HobLib.h>
+#include <Library/UefiLib.h>
+#include <Library/DxeServicesTableLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/IoLib.h>
+
+#include <Protocol/Decompress.h>
+#include <Protocol/PciIo.h>
+#include <Protocol/FirmwareVolume2.h>
+#include <Protocol/SimpleFileSystem.h>
+
+#include <Guid/Acpi.h>
+#include <Guid/SmBios.h>
+#include <Guid/Mps.h>
+#include <Guid/HobList.h>
+#include <Guid/GlobalVariable.h>
+
+extern BDS_CONSOLE_CONNECT_ENTRY  gPlatformConsole[];
+extern EFI_DEVICE_PATH_PROTOCOL   *gPlatformConnectSequence[];
+extern EFI_DEVICE_PATH_PROTOCOL   *gPlatformDriverOption[];
+extern EFI_DEVICE_PATH_PROTOCOL   *gPlatformRootBridges[];
+extern ACPI_HID_DEVICE_PATH       gPnpPs2KeyboardDeviceNode;
+extern ACPI_HID_DEVICE_PATH       gPnp16550ComPortDeviceNode;
+extern UART_DEVICE_PATH           gUartDeviceNode;
+extern VENDOR_DEVICE_PATH         gTerminalTypeDeviceNode;
+//
+//
+//
+#define VarConsoleInpDev        L"ConInDev"
+#define VarConsoleInp           L"ConIn"
+#define VarConsoleOutDev        L"ConOutDev"
+#define VarConsoleOut           L"ConOut"
+#define VarErrorOutDev          L"ErrOutDev"
+#define VarErrorOut             L"ErrOut"
+
+#define PCI_DEVICE_PATH_NODE(Func, Dev) \
+  { \
+    { \
+      HARDWARE_DEVICE_PATH, \
+      HW_PCI_DP, \
+      { \
+        (UINT8) (sizeof (PCI_DEVICE_PATH)), \
+        (UINT8) ((sizeof (PCI_DEVICE_PATH)) >> 8) \
+      } \
+    }, \
+    (Func), \
+    (Dev) \
+  }
+
+#define PNPID_DEVICE_PATH_NODE(PnpId) \
+  { \
+    { \
+      ACPI_DEVICE_PATH, \
+      ACPI_DP, \
+      { \
+        (UINT8) (sizeof (ACPI_HID_DEVICE_PATH)), \
+        (UINT8) ((sizeof (ACPI_HID_DEVICE_PATH)) >> 8) \
+      }, \
+    }, \
+    EISA_PNP_ID((PnpId)), \
+    0 \
+  }
+
+#define gPciRootBridge \
+  PNPID_DEVICE_PATH_NODE(0x0A03)
+
+#define gPciIsaBridge \
+  PCI_DEVICE_PATH_NODE(0, 0x1f)
+
+#define gP2PBridge \
+  PCI_DEVICE_PATH_NODE(0, 0x1e)
+
+#define gPnpPs2Keyboard \
+  PNPID_DEVICE_PATH_NODE(0x0303)
+
+#define gPnp16550ComPort \
+  PNPID_DEVICE_PATH_NODE(0x0501)
+
+#define gUart \
+  { \
+    { \
+      MESSAGING_DEVICE_PATH, \
+      MSG_UART_DP, \
+      { \
+        (UINT8) (sizeof (UART_DEVICE_PATH)), \
+        (UINT8) ((sizeof (UART_DEVICE_PATH)) >> 8) \
+      } \
+    }, \
+    0, \
+    115200, \
+    8, \
+    1, \
+    1 \
+  }
+
+#define gPcAnsiTerminal \
+  { \
+    { \
+      MESSAGING_DEVICE_PATH, \
+      MSG_VENDOR_DP, \
+      { \
+        (UINT8) (sizeof (VENDOR_DEVICE_PATH)), \
+        (UINT8) ((sizeof (VENDOR_DEVICE_PATH)) >> 8) \
+      } \
+    }, \
+    DEVICE_PATH_MESSAGING_PC_ANSI \
+  }
+
+#define gEndEntire \
+  { \
+    END_DEVICE_PATH_TYPE, \
+    END_ENTIRE_DEVICE_PATH_SUBTYPE, \
+    { \
+      END_DEVICE_PATH_LENGTH, \
+      0 \
+    } \
+  }
+
+#define PCI_CLASS_SCC          0x07
+#define PCI_SUBCLASS_SERIAL    0x00
+#define PCI_IF_16550           0x02
+#define IS_PCI_16550SERIAL(_p)           IS_CLASS3 (_p, PCI_CLASS_SCC, PCI_SUBCLASS_SERIAL, PCI_IF_16550)
+
+#define EFI_SYSTEM_TABLE_MAX_ADDRESS 0xFFFFFFFF
+#define SYS_TABLE_PAD(ptr) (((~ptr) +1) & 0x07 )
+
+#define IS_PCI_ISA_PDECODE(_p)        IS_CLASS3 (_p, PCI_CLASS_BRIDGE, PCI_CLASS_BRIDGE_ISA_PDECODE, 0)
+
+//
+// Platform Root Bridge
+//
+typedef struct {
+  ACPI_HID_DEVICE_PATH      PciRootBridge;
+  EFI_DEVICE_PATH_PROTOCOL  End;
+} PLATFORM_ROOT_BRIDGE_DEVICE_PATH;
+
+typedef struct {
+  ACPI_HID_DEVICE_PATH      PciRootBridge;
+  PCI_DEVICE_PATH           IsaBridge;
+  ACPI_HID_DEVICE_PATH      Keyboard;
+  EFI_DEVICE_PATH_PROTOCOL  End;
+} PLATFORM_DUMMY_ISA_KEYBOARD_DEVICE_PATH;
+
+typedef struct {
+  ACPI_HID_DEVICE_PATH      PciRootBridge;
+  PCI_DEVICE_PATH           IsaBridge;
+  ACPI_HID_DEVICE_PATH      IsaSerial;
+  UART_DEVICE_PATH          Uart;
+  VENDOR_DEVICE_PATH        TerminalType;
+  EFI_DEVICE_PATH_PROTOCOL  End;
+} PLATFORM_DUMMY_ISA_SERIAL_DEVICE_PATH;
+
+typedef struct {
+  ACPI_HID_DEVICE_PATH      PciRootBridge;
+  PCI_DEVICE_PATH           VgaDevice;
+  EFI_DEVICE_PATH_PROTOCOL  End;
+} PLATFORM_DUMMY_PCI_VGA_DEVICE_PATH;
+
+typedef struct {
+  ACPI_HID_DEVICE_PATH      PciRootBridge;
+  PCI_DEVICE_PATH           PciBridge;
+  PCI_DEVICE_PATH           SerialDevice;
+  UART_DEVICE_PATH          Uart;
+  VENDOR_DEVICE_PATH        TerminalType;
+  EFI_DEVICE_PATH_PROTOCOL  End;
+} PLATFORM_DUMMY_PCI_SERIAL_DEVICE_PATH;
+
+//
+// the short form device path for Usb keyboard
+//
+#define CLASS_HID           3
+#define SUBCLASS_BOOT       1
+#define PROTOCOL_KEYBOARD   1
+
+typedef struct {
+  USB_CLASS_DEVICE_PATH           UsbClass;
+  EFI_DEVICE_PATH_PROTOCOL        End;
+} USB_CLASS_FORMAT_DEVICE_PATH;  
+
+extern PLATFORM_ROOT_BRIDGE_DEVICE_PATH  gPlatformRootBridge0;
+
+//
+// Platform BDS Functions
+//
+
+VOID
+PlatformBdsGetDriverOption (
+  IN LIST_ENTRY               *BdsDriverLists
+  );
+
+EFI_STATUS
+BdsMemoryTest (
+  EXTENDMEM_COVERAGE_LEVEL Level
+  );
+
+EFI_STATUS
+PlatformBdsShowProgress (
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL TitleForeground,
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL TitleBackground,
+  CHAR16                        *Title,
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL ProgressColor,
+  UINTN                         Progress,
+  UINTN                         PreviousValue
+  );
+
+VOID
+PlatformBdsConnectSequence (
+  VOID
+  );
+
+EFI_STATUS
+ProcessCapsules (
+  EFI_BOOT_MODE BootMode
+  );
+
+EFI_STATUS
+PlatformBdsConnectConsole (
+  IN BDS_CONSOLE_CONNECT_ENTRY   *PlatformConsole
+  );
+
+EFI_STATUS
+PlatformBdsNoConsoleAction (
+  VOID
+  );
+
+EFI_STATUS
+ConvertMpsTable (
+  IN OUT  VOID     **Table
+  );
+  
+EFI_STATUS
+ConvertSmbiosTable (
+  IN OUT VOID       **Table
+  );
+  
+EFI_STATUS
+ConvertAcpiTable (
+ IN      UINTN      TableLen,
+ IN OUT  VOID       **Table
+  );
+
+EFI_STATUS
+ConvertSystemTable (
+ IN     EFI_GUID   *TableGuid,
+ IN OUT VOID       **Table
+  );
+
+VOID
+PlatformBdsEnterFrontPage (
+  IN UINT16                 TimeoutDefault,
+  IN BOOLEAN                ConnectAllHappened
+  );
+
+/**
+  Loads and boots UEFI Linux via the FwCfg interface.
+
+  @retval    EFI_NOT_FOUND - The Linux kernel was not found
+
+**/
+EFI_STATUS
+TryRunningQemuKernel (
+  VOID
+  );
+
+#endif // _PLATFORM_SPECIFIC_BDS_PLATFORM_H_
diff --git a/corebootPkg/Library/PlatformBdsLib/PlatformBdsLib.inf b/corebootPkg/Library/PlatformBdsLib/PlatformBdsLib.inf
new file mode 100644
index 0000000..11ed7a8
--- /dev/null
+++ b/corebootPkg/Library/PlatformBdsLib/PlatformBdsLib.inf
@@ -0,0 +1,59 @@
+## @file
+#  Platform BDS customizations library.
+#
+#  Copyright (c) 2007 - 2010, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#  
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformBdsLib
+  FILE_GUID                      = F844172E-9985-44f2-BADE-0DD783462E95
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformBdsLib|DXE_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  BdsPlatform.c
+  PlatformData.c
+  BdsPlatform.h
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  IntelFrameworkModulePkg/IntelFrameworkModulePkg.dec
+  corebootPkg/corebootPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  MemoryAllocationLib
+  UefiBootServicesTableLib
+  BaseMemoryLib
+  DebugLib
+  PcdLib
+  GenericBdsLib
+  PciLib
+
+[Pcd]
+  gEfiIntelFrameworkModulePkgTokenSpaceGuid.PcdPlatformBootTimeOut
+  gEfiIntelFrameworkModulePkgTokenSpaceGuid.PcdLogoFile
+
+[Pcd.IA32, Pcd.X64]
+  gEfiMdePkgTokenSpaceGuid.PcdFSBClock
+
+[Protocols]
+  gEfiDecompressProtocolGuid
+
diff --git a/corebootPkg/Library/PlatformBdsLib/PlatformData.c b/corebootPkg/Library/PlatformBdsLib/PlatformData.c
new file mode 100644
index 0000000..1a30531
--- /dev/null
+++ b/corebootPkg/Library/PlatformBdsLib/PlatformData.c
@@ -0,0 +1,64 @@
+/** @file
+  Defined the platform specific device path which will be used by
+  platform Bbd to perform the platform policy connect.
+
+  Copyright (c) 2004 - 2008, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "BdsPlatform.h"
+
+//
+// Predefined platform default time out value
+//
+UINT16                      gPlatformBootTimeOutDefault = 5;
+
+ACPI_HID_DEVICE_PATH       gPnpPs2KeyboardDeviceNode  = gPnpPs2Keyboard;
+ACPI_HID_DEVICE_PATH       gPnp16550ComPortDeviceNode = gPnp16550ComPort;
+UART_DEVICE_PATH           gUartDeviceNode            = gUart;
+VENDOR_DEVICE_PATH         gTerminalTypeDeviceNode    = gPcAnsiTerminal;
+
+//
+// Predefined platform root bridge
+//
+PLATFORM_ROOT_BRIDGE_DEVICE_PATH  gPlatformRootBridge0 = {
+  gPciRootBridge,
+  gEndEntire
+};
+
+EFI_DEVICE_PATH_PROTOCOL          *gPlatformRootBridges[] = {
+  (EFI_DEVICE_PATH_PROTOCOL *) &gPlatformRootBridge0,
+  NULL
+};
+
+//
+// Platform specific keyboard device path
+//
+
+//
+// Predefined platform default console device path
+//
+BDS_CONSOLE_CONNECT_ENTRY   gPlatformConsole[] = {
+  {
+    NULL,
+    0
+  }
+};
+
+//
+// Predefined platform specific driver option
+//
+EFI_DEVICE_PATH_PROTOCOL    *gPlatformDriverOption[] = { NULL };
+
+//
+// Predefined platform connect sequence
+//
+EFI_DEVICE_PATH_PROTOCOL    *gPlatformConnectSequence[] = { NULL };
+
diff --git a/corebootPkg/Library/PlatformDebugLibIoPort/DebugLib.c b/corebootPkg/Library/PlatformDebugLibIoPort/DebugLib.c
new file mode 100644
index 0000000..84299ca
--- /dev/null
+++ b/corebootPkg/Library/PlatformDebugLibIoPort/DebugLib.c
@@ -0,0 +1,269 @@
+/** @file
+  Base Debug library instance for QEMU debug port.
+  It uses PrintLib to send debug messages to a fixed I/O port.
+
+  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2012, Red Hat, Inc.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Base.h>
+#include <Uefi.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseLib.h>
+#include <Library/IoLib.h>
+#include <Library/PrintLib.h>
+#include <Library/PcdLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugPrintErrorLevelLib.h>
+
+//
+// Define the maximum debug and assert message length that this library supports
+//
+#define MAX_DEBUG_MESSAGE_LENGTH  0x100
+
+/**
+  This constructor function does not have to do anything.
+
+  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.
+
+**/
+RETURN_STATUS
+EFIAPI
+PlatformDebugLibIoPortConstructor (
+  VOID
+  )
+{
+  return EFI_SUCCESS;
+}
+
+/**
+  Prints a debug message to the debug output device if the specified error level is enabled.
+
+  If any bit in ErrorLevel is also set in DebugPrintErrorLevelLib function
+  GetDebugPrintErrorLevel (), then print the message specified by Format and the
+  associated variable argument list to the debug output device.
+
+  If Format is NULL, then ASSERT().
+
+  @param  ErrorLevel  The error level of the debug message.
+  @param  Format      Format string for the debug message to print.
+  @param  ...         Variable argument list whose contents are accessed
+                      based on the format string specified by Format.
+
+**/
+VOID
+EFIAPI
+DebugPrint (
+  IN  UINTN        ErrorLevel,
+  IN  CONST CHAR8  *Format,
+  ...
+  )
+{
+  CHAR8    Buffer[MAX_DEBUG_MESSAGE_LENGTH];
+  VA_LIST  Marker;
+  UINT8    *Ptr;
+
+  //
+  // If Format is NULL, then ASSERT().
+  //
+  ASSERT (Format != NULL);
+
+  //
+  // Check driver debug mask value and global mask
+  //
+  if ((ErrorLevel & GetDebugPrintErrorLevel ()) == 0) {
+    return;
+  }
+
+  //
+  // Convert the DEBUG() message to an ASCII String
+  //
+  VA_START (Marker, Format);
+  AsciiVSPrint (Buffer, sizeof (Buffer), Format, Marker);
+  VA_END (Marker);
+
+  //
+  // Send the print string to the debug I/O port
+  //
+  for (Ptr = (UINT8 *) Buffer; *Ptr; Ptr++) {
+    IoWrite8 (PcdGet16(PcdDebugIoPort), *Ptr);
+  }
+}
+
+
+/**
+  Prints an assert message containing a filename, line number, and description.
+  This may be followed by a breakpoint or a dead loop.
+
+  Print a message of the form "ASSERT <FileName>(<LineNumber>): <Description>\n"
+  to the debug output device.  If DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED bit of
+  PcdDebugProperyMask is set then CpuBreakpoint() is called. Otherwise, if
+  DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED bit of PcdDebugProperyMask is set then
+  CpuDeadLoop() is called.  If neither of these bits are set, then this function
+  returns immediately after the message is printed to the debug output device.
+  DebugAssert() must actively prevent recursion.  If DebugAssert() is called while
+  processing another DebugAssert(), then DebugAssert() must return immediately.
+
+  If FileName is NULL, then a <FileName> string of "(NULL) Filename" is printed.
+  If Description is NULL, then a <Description> string of "(NULL) Description" is printed.
+
+  @param  FileName     The pointer to the name of the source file that generated the assert condition.
+  @param  LineNumber   The line number in the source file that generated the assert condition
+  @param  Description  The pointer to the description of the assert condition.
+
+**/
+VOID
+EFIAPI
+DebugAssert (
+  IN CONST CHAR8  *FileName,
+  IN UINTN        LineNumber,
+  IN CONST CHAR8  *Description
+  )
+{
+  CHAR8  Buffer[MAX_DEBUG_MESSAGE_LENGTH];
+  UINT8 *Ptr;
+
+  //
+  // Generate the ASSERT() message in Ascii format
+  //
+  AsciiSPrint (Buffer, sizeof (Buffer), "ASSERT %a(%d): %a\n", FileName, LineNumber, Description);
+
+  //
+  // Send the print string to the Console Output device
+  //
+  for (Ptr = (UINT8 *) Buffer; *Ptr; Ptr++) {
+    IoWrite8 (PcdGet16(PcdDebugIoPort), *Ptr);
+  }
+
+  //
+  // Generate a Breakpoint, DeadLoop, or NOP based on PCD settings
+  //
+  if ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED) != 0) {
+    CpuBreakpoint ();
+  } else if ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED) != 0) {
+    CpuDeadLoop ();
+  }
+}
+
+
+/**
+  Fills a target buffer with PcdDebugClearMemoryValue, and returns the target buffer.
+
+  This function fills Length bytes of Buffer with the value specified by
+  PcdDebugClearMemoryValue, and returns Buffer.
+
+  If Buffer is NULL, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param   Buffer  The pointer to the target buffer to be filled with PcdDebugClearMemoryValue.
+  @param   Length  The number of bytes in Buffer to fill with zeros PcdDebugClearMemoryValue.
+
+  @return  Buffer  The pointer to the target buffer filled with PcdDebugClearMemoryValue.
+
+**/
+VOID *
+EFIAPI
+DebugClearMemory (
+  OUT VOID  *Buffer,
+  IN UINTN  Length
+  )
+{
+  //
+  // If Buffer is NULL, then ASSERT().
+  //
+  ASSERT (Buffer != NULL);
+
+  //
+  // SetMem() checks for the the ASSERT() condition on Length and returns Buffer
+  //
+  return SetMem (Buffer, Length, PcdGet8(PcdDebugClearMemoryValue));
+}
+
+
+/**
+  Returns TRUE if ASSERT() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugAssertEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_PRINT_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugPrintEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_PRINT_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG_CODE() macros are enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_DEBUG_CODE_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugCodeEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_CODE_ENABLED) != 0);
+}
+
+
+/**
+  Returns TRUE if DEBUG_CLEAR_MEMORY() macro is enabled.
+
+  This function returns TRUE if the DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of
+  PcdDebugProperyMask is set.  Otherwise FALSE is returned.
+
+  @retval  TRUE    The DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of PcdDebugProperyMask is set.
+  @retval  FALSE   The DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED bit of PcdDebugProperyMask is clear.
+
+**/
+BOOLEAN
+EFIAPI
+DebugClearMemoryEnabled (
+  VOID
+  )
+{
+  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED) != 0);
+}
+
diff --git a/corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf b/corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
new file mode 100644
index 0000000..6fd47be
--- /dev/null
+++ b/corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
@@ -0,0 +1,50 @@
+## @file
+#  Instance of Debug Library for the QEMU debug console port.
+#  It uses Print Library to produce formatted output strings.
+#
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#  Copyright (c) 2012, Red Hat, Inc.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformDebugLibIoPort
+  FILE_GUID                      = DF934DA3-CD31-49FE-AF50-B3C87C79325F
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = DebugLib
+  CONSTRUCTOR                    = PlatformDebugLibIoPortConstructor
+
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  DebugLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  corebootPkg/corebootPkg.dec
+
+[LibraryClasses]
+  BaseMemoryLib
+  IoLib
+  PcdLib
+  PrintLib
+  BaseLib
+  DebugPrintErrorLevelLib
+
+[Pcd]
+  gUefiCorebootPkgTokenSpaceGuid.PcdDebugIoPort                ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugClearMemoryValue        ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask            ## CONSUMES
+
diff --git a/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.c b/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.c
new file mode 100644
index 0000000..de0e4fa
--- /dev/null
+++ b/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.c
@@ -0,0 +1,40 @@
+/** @file
+  Provides a platform-specific method to enable Secure Boot Custom Mode setup.
+
+  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+#include <Library/PcdLib.h>
+
+/**
+
+  This function provides a platform-specific method to detect whether the platform
+  is operating by a physically present user. 
+
+  Programmatic changing of platform security policy (such as disable Secure Boot,
+  or switch between Standard/Custom Secure Boot mode) MUST NOT be possible during
+  Boot Services or after exiting EFI Boot Services. Only a physically present user
+  is allowed to perform these operations.
+
+  NOTE THAT: This function cannot depend on any EFI Variable Service since they are
+  not available when this function is called in AuthenticateVariable driver.
+  
+  @retval  TRUE       The platform is operated by a physically present user.
+  @retval  FALSE      The platform is NOT operated by a physically present user.
+
+**/
+BOOLEAN
+EFIAPI
+UserPhysicalPresent (
+  VOID
+  )
+{
+  return TRUE;
+}
diff --git a/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.inf b/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.inf
new file mode 100644
index 0000000..267bc18
--- /dev/null
+++ b/corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.inf
@@ -0,0 +1,33 @@
+## @file
+#  Provides a platform-specific method to enable Secure Boot Custom Mode setup.
+#
+#  Copyright (c) 2008 - 2012, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformSecureLib
+  FILE_GUID                      = 4204D78D-EDBF-4cee-BE80-3881457CF344
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformSecureLib|DXE_RUNTIME_DRIVER DXE_SMM_DRIVER DXE_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  PlatformSecureLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
diff --git a/corebootPkg/Library/ResetSystemLib/ResetSystemLib.c b/corebootPkg/Library/ResetSystemLib/ResetSystemLib.c
new file mode 100644
index 0000000..52406ad
--- /dev/null
+++ b/corebootPkg/Library/ResetSystemLib/ResetSystemLib.c
@@ -0,0 +1,101 @@
+/** @file
+  Reset System Library functions for OVMF
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Base.h>
+
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Library/IoLib.h>
+
+VOID
+AcpiPmControl (
+  UINTN SuspendType
+  )
+{
+  ASSERT (SuspendType < 6);
+
+  IoAndThenOr16 (0x404, (UINT16) ~0x3c00, (UINT16) (SuspendType << 10));
+  IoOr16 (0x404, BIT13);
+  CpuDeadLoop ();
+}
+
+/**
+  Calling this function causes a system-wide reset. This sets
+  all circuitry within the system to its initial state. This type of reset
+  is asynchronous to system operation and operates without regard to
+  cycle boundaries.
+
+  System reset should not return, if it returns, it means the system does
+  not support cold reset.
+**/
+VOID
+EFIAPI
+ResetCold (
+  VOID
+  )
+{
+  IoWrite8 (0x64, 0xfe);
+}
+
+/**
+  Calling this function causes a system-wide initialization. The processors
+  are set to their initial state, and pending cycles are not corrupted.
+
+  System reset should not return, if it returns, it means the system does
+  not support warm reset.
+**/
+VOID
+EFIAPI
+ResetWarm (
+  VOID
+  )
+{
+  IoWrite8 (0x64, 0xfe);
+}
+
+/**
+  Calling this function causes the system to enter a power state equivalent
+  to the ACPI G2/S5 or G3 states.
+
+  System shutdown should not return, if it returns, it means the system does
+  not support shut down reset.
+**/
+VOID
+EFIAPI
+ResetShutdown (
+  VOID
+  )
+{
+  AcpiPmControl (0);
+  ASSERT (FALSE);
+}
+
+
+/**
+  Calling this function causes the system to enter a power state for capsule
+  update.
+
+  Reset update should not return, if it returns, it means the system does
+  not support capsule update.
+
+**/
+VOID
+EFIAPI
+EnterS3WithImmediateWake (
+  VOID
+  )
+{
+  AcpiPmControl (1);
+  ASSERT (FALSE);
+}
diff --git a/corebootPkg/Library/ResetSystemLib/ResetSystemLib.inf b/corebootPkg/Library/ResetSystemLib/ResetSystemLib.inf
new file mode 100644
index 0000000..0694b4d
--- /dev/null
+++ b/corebootPkg/Library/ResetSystemLib/ResetSystemLib.inf
@@ -0,0 +1,38 @@
+## @file
+#  Library instance for ResetSystem library class for OVMF
+#
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = ResetSystemLib
+  FILE_GUID                      = 66564872-21d4-4d2a-a68b-1e844f980820
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = ResetSystemLib
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF
+#
+
+[Sources]
+  ResetSystemLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+
+[LibraryClasses]
+  DebugLib
+  IoLib
+
diff --git a/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.c b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.c
new file mode 100644
index 0000000..112f20e
--- /dev/null
+++ b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.c
@@ -0,0 +1,857 @@
+/** @file
+  Serialize Variables Library implementation
+
+  Copyright (c) 2004 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "SerializeVariablesLib.h"
+
+/**
+  Serialization format:
+
+  The SerializeVariablesLib interface does not specify a format
+  for the serialization of the variable data.  This library uses
+  a packed array of a non-uniformly sized data structure elements.
+
+  Each variable is stored (packed) as:
+    UINT32   VendorNameSize;  // Name size in bytes
+    CHAR16   VendorName[?];   // The variable unicode name including the
+                              // null terminating character.
+    EFI_GUID VendorGuid;      // The variable GUID
+    UINT32   DataSize;        // The size of variable data in bytes
+    UINT8    Data[?];         // The variable data
+
+**/
+
+
+/**
+  Unpacks the next variable from the buffer
+
+  @param[in]  Buffer - Buffer pointing to the next variable instance
+                On subsequent calls, the pointer should be incremented
+                by the returned SizeUsed value.
+  @param[in]  MaxSize - Max allowable size for the variable data
+                On subsequent calls, this should be decremented
+                by the returned SizeUsed value.
+  @param[out] Name - Variable name string (address in Buffer)
+  @param[out] NameSize - Size of Name in bytes
+  @param[out] Guid - GUID of variable (address in Buffer)
+  @param[out] Attributes - Attributes of variable
+  @param[out] Data - Buffer containing Data for variable (address in Buffer)
+  @param[out] DataSize - Size of Data in bytes
+  @param[out] SizeUsed - Total size used for this variable instance in Buffer
+
+  @return     EFI_STATUS based on the success or failure of the operation
+
+**/
+STATIC
+EFI_STATUS
+UnpackVariableFromBuffer (
+  IN  VOID     *Buffer,
+  IN  UINTN    MaxSize,
+  OUT CHAR16   **Name,
+  OUT UINT32   *NameSize,
+  OUT EFI_GUID **Guid,
+  OUT UINT32   *Attributes,
+  OUT UINT32   *DataSize,
+  OUT VOID     **Data,
+  OUT UINTN    *SizeUsed
+  )
+{
+  UINT8  *BytePtr;
+  UINTN  Offset;
+
+  BytePtr = (UINT8*)Buffer;
+  Offset = 0;
+
+  *NameSize = *(UINT32*) (BytePtr + Offset);
+  Offset = Offset + sizeof (UINT32);
+
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *Name = (CHAR16*) (BytePtr + Offset);
+  Offset = Offset + *(UINT32*)BytePtr;
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *Guid = (EFI_GUID*) (BytePtr + Offset);
+  Offset = Offset + sizeof (EFI_GUID);
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *Attributes = *(UINT32*) (BytePtr + Offset);
+  Offset = Offset + sizeof (UINT32);
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *DataSize = *(UINT32*) (BytePtr + Offset);
+  Offset = Offset + sizeof (UINT32);
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *Data = (VOID*) (BytePtr + Offset);
+  Offset = Offset + *DataSize;
+  if (Offset > MaxSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *SizeUsed = Offset;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Iterates through the variables in the buffer, and calls a callback
+  function for each variable found.
+
+  @param[in]  CallbackFunction - Function called for each variable instance
+  @param[in]  Context - Passed to each call of CallbackFunction
+  @param[in]  Buffer - Buffer containing serialized variables
+  @param[in]  MaxSize - Size of Buffer in bytes
+
+  @return     EFI_STATUS based on the success or failure of the operation
+
+**/
+STATIC
+EFI_STATUS
+IterateVariablesInBuffer (
+  IN VARIABLE_SERIALIZATION_ITERATION_CALLBACK  CallbackFunction,
+  IN VOID                                       *CallbackContext,
+  IN VOID                                       *Buffer,
+  IN UINTN                                      MaxSize
+  )
+{
+  RETURN_STATUS Status;
+  UINTN         TotalSizeUsed;
+  UINTN         SizeUsed;
+
+  CHAR16        *Name;
+  UINT32        NameSize;
+  CHAR16        *AlignedName;
+  UINT32        AlignedNameMaxSize;
+  EFI_GUID      *Guid;
+  UINT32        Attributes;
+  UINT32        DataSize;
+  VOID          *Data;
+
+  SizeUsed = 0;
+  AlignedName = NULL;
+  AlignedNameMaxSize = 0;
+  Name = NULL;
+  Guid = NULL;
+  Attributes = 0;
+  DataSize = 0;
+  Data = NULL;
+
+  for (
+    Status = EFI_SUCCESS, TotalSizeUsed = 0;
+    !EFI_ERROR (Status) && (TotalSizeUsed < MaxSize);
+    ) {
+    Status = UnpackVariableFromBuffer (
+               (VOID*) ((UINT8*) Buffer + TotalSizeUsed),
+               (MaxSize - TotalSizeUsed),
+               &Name,
+               &NameSize,
+               &Guid,
+               &Attributes,
+               &DataSize,
+               &Data,
+               &SizeUsed
+               );
+    if (EFI_ERROR (Status)) {
+      return Status;
+    }
+
+    //
+    // We copy the name to a separately allocated buffer,
+    // to be sure it is 16-bit aligned.
+    //
+    if (NameSize > AlignedNameMaxSize) {
+      if (AlignedName != NULL) {
+        FreePool (AlignedName);
+      }
+      AlignedName = AllocatePool (NameSize);
+    }
+    if (AlignedName == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    CopyMem (AlignedName, Name, NameSize);
+
+    TotalSizeUsed = TotalSizeUsed + SizeUsed;
+
+    //
+    // Run the callback function
+    //
+    Status = (*CallbackFunction) (
+               CallbackContext,
+               AlignedName,
+               Guid,
+               Attributes,
+               DataSize,
+               Data
+               );
+
+  }
+
+  if (AlignedName != NULL) {
+    FreePool (AlignedName);
+  }
+
+  //
+  // Make sure the entire buffer was used, or else return an error
+  //
+  if (TotalSizeUsed != MaxSize) {
+    DEBUG ((
+      EFI_D_ERROR,
+      "Deserialize variables error: TotalSizeUsed(%d) != MaxSize(%d)\n",
+      TotalSizeUsed,
+      MaxSize
+      ));
+    return EFI_INVALID_PARAMETER;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+STATIC
+RETURN_STATUS
+EFIAPI
+IterateVariablesCallbackNop (
+  IN  VOID                         *Context,
+  IN  CHAR16                       *VariableName,
+  IN  EFI_GUID                     *VendorGuid,
+  IN  UINT32                       Attributes,
+  IN  UINTN                        DataSize,
+  IN  VOID                         *Data
+  )
+{
+  return RETURN_SUCCESS;
+}
+
+
+STATIC
+RETURN_STATUS
+EFIAPI
+IterateVariablesCallbackSetInInstance (
+  IN  VOID                         *Context,
+  IN  CHAR16                       *VariableName,
+  IN  EFI_GUID                     *VendorGuid,
+  IN  UINT32                       Attributes,
+  IN  UINTN                        DataSize,
+  IN  VOID                         *Data
+  )
+{
+  EFI_HANDLE  Instance;
+
+  Instance = (EFI_HANDLE) Context;
+
+  return SerializeVariablesAddVariable (
+           Instance,
+           VariableName,
+           VendorGuid,
+           Attributes,
+           DataSize,
+           Data
+           );
+}
+
+
+STATIC
+RETURN_STATUS
+EFIAPI
+IterateVariablesCallbackSetSystemVariable (
+  IN  VOID                         *Context,
+  IN  CHAR16                       *VariableName,
+  IN  EFI_GUID                     *VendorGuid,
+  IN  UINT32                       Attributes,
+  IN  UINTN                        DataSize,
+  IN  VOID                         *Data
+  )
+{
+  return gRT->SetVariable (
+           VariableName,
+           VendorGuid,
+           Attributes,
+           DataSize,
+           Data
+           );
+}
+
+
+STATIC
+RETURN_STATUS
+EnsureExtraBufferSpace (
+  IN  SV_INSTANCE  *Instance,
+  IN  UINTN        Size
+  )
+{
+  VOID *NewBuffer;
+  UINTN NewSize;
+
+  NewSize = Instance->DataSize + Size;
+  if (NewSize <= Instance->BufferSize) {
+    return RETURN_SUCCESS;
+  }
+
+  //
+  // Double the required size to lessen the need to re-allocate in the future
+  //
+  NewSize = 2 * NewSize;
+
+  NewBuffer = AllocatePool (NewSize);
+  if (NewBuffer == NULL) {
+    return RETURN_OUT_OF_RESOURCES;
+  }
+
+  if (Instance->BufferPtr != NULL) {
+    CopyMem (NewBuffer, Instance->BufferPtr, Instance->DataSize);
+    FreePool (Instance->BufferPtr);
+  }
+
+  Instance->BufferPtr = NewBuffer;
+  Instance->BufferSize = NewSize;
+
+  return RETURN_SUCCESS;
+}
+
+
+STATIC
+VOID
+AppendToBuffer (
+  IN  SV_INSTANCE  *Instance,
+  IN  VOID         *Data,
+  IN  UINTN        Size
+  )
+{
+  UINTN NewSize;
+
+  ASSERT (Instance != NULL);
+  ASSERT (Data != NULL);
+
+  NewSize = Instance->DataSize + Size;
+  ASSERT ((Instance->DataSize + Size) <= Instance->BufferSize);
+
+  CopyMem (
+    (VOID*) (((UINT8*) (Instance->BufferPtr)) + Instance->DataSize),
+    Data,
+    Size
+    );
+
+  Instance->DataSize = NewSize;
+}
+
+
+/**
+  Creates a new variable serialization instance
+
+  @param[out]  Handle - Handle for a variable serialization instance
+
+  @retval      RETURN_SUCCESS - The variable serialization instance was
+                 successfully created.
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 create the variable serialization instance.
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesNewInstance (
+  OUT EFI_HANDLE                      *Handle
+  )
+{
+  SV_INSTANCE  *New;
+
+  New = AllocateZeroPool (sizeof (*New));
+  if (New == NULL) {
+    return RETURN_OUT_OF_RESOURCES;
+  }
+
+  New->Signature = SV_SIGNATURE;
+
+  *Handle = (EFI_HANDLE) New;
+  return RETURN_SUCCESS;
+}
+
+
+/**
+  Free memory associated with a variable serialization instance
+
+  @param[in]  Handle - Handle for a variable serialization instance
+
+  @retval      RETURN_SUCCESS - The variable serialization instance was
+                 successfully freed.
+  @retval      RETURN_INVALID_PARAMETER - Handle was not a valid
+                 variable serialization instance.
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesFreeInstance (
+  IN EFI_HANDLE Handle
+  )
+{
+  SV_INSTANCE    *Instance;
+
+  Instance = SV_FROM_HANDLE (Handle);
+
+  if (Instance->Signature != SV_SIGNATURE) {
+    return RETURN_INVALID_PARAMETER;
+  }
+
+  Instance->Signature = 0;
+
+  if (Instance->BufferPtr != NULL) {
+    FreePool (Instance->BufferPtr);
+  }
+
+  FreePool (Instance);
+
+  return RETURN_SUCCESS;
+}
+
+
+/**
+  Creates a new variable serialization instance using the given
+  binary representation of the variables to fill the new instance
+
+  @param[out] Handle - Handle for a variable serialization instance
+  @param[in]  Buffer - A buffer with the serialized representation
+                of the variables.  Must be the same format as produced
+                by SerializeVariablesToBuffer.
+  @param[in]  Size - This is the size of the binary representation
+                of the variables.
+
+  @retval      RETURN_SUCCESS - The binary representation was successfully
+                 imported into a new variable serialization instance
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 create the new variable serialization instance
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesNewInstanceFromBuffer (
+  OUT EFI_HANDLE                          *Handle,
+  IN  VOID                                *Buffer,
+  IN  UINTN                               Size
+  )
+{
+  RETURN_STATUS Status;
+
+  Status = SerializeVariablesNewInstance (Handle);
+  if (RETURN_ERROR (Status)) {
+    return Status;
+  }
+
+  Status = IterateVariablesInBuffer (
+             IterateVariablesCallbackNop,
+             NULL,
+             Buffer,
+             Size
+             );
+  if (RETURN_ERROR (Status)) {
+    SerializeVariablesFreeInstance (*Handle);
+    return Status;
+  }
+
+  Status = IterateVariablesInBuffer (
+             IterateVariablesCallbackSetInInstance,
+             (VOID*) *Handle,
+             Buffer,
+             Size
+             );
+  if (RETURN_ERROR (Status)) {
+    SerializeVariablesFreeInstance (*Handle);
+    return Status;
+  }
+
+  return Status;
+}
+
+
+/**
+  Iterates all variables found with RuntimeServices GetNextVariableName
+
+  @param[in]   CallbackFunction - Function called for each variable instance
+  @param[in]   Context - Passed to each call of CallbackFunction
+
+  @retval      RETURN_SUCCESS - All variables were iterated without the
+                 CallbackFunction returning an error
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 iterate through the variables
+  @return      Any of RETURN_ERROR indicates an error reading the variable
+                 or an error was returned from CallbackFunction
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesIterateSystemVariables (
+  IN VARIABLE_SERIALIZATION_ITERATION_CALLBACK CallbackFunction,
+  IN VOID                                      *Context
+  )
+{
+  RETURN_STATUS               Status;
+  UINTN                       VariableNameBufferSize;
+  UINTN                       VariableNameSize;
+  CHAR16                      *VariableName;
+  EFI_GUID                    VendorGuid;
+  UINTN                       VariableDataBufferSize;
+  UINTN                       VariableDataSize;
+  VOID                        *VariableData;
+  UINT32                      VariableAttributes;
+  VOID                        *NewBuffer;
+
+  //
+  // Initialize the variable name and data buffer variables.
+  //
+  VariableNameBufferSize = sizeof (CHAR16);
+  VariableName = AllocateZeroPool (VariableNameBufferSize);
+
+  VariableDataBufferSize = 0;
+  VariableData = NULL;
+
+  for (;;) {
+    //
+    // Get the next variable name and guid
+    //
+    VariableNameSize = VariableNameBufferSize;
+    Status = gRT->GetNextVariableName (
+                    &VariableNameSize,
+                    VariableName,
+                    &VendorGuid
+                    );
+    if (Status == EFI_BUFFER_TOO_SMALL) {
+      //
+      // The currently allocated VariableName buffer is too small,
+      // so we allocate a larger buffer, and copy the old buffer
+      // to it.
+      //
+      NewBuffer = AllocatePool (VariableNameSize);
+      if (NewBuffer == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        break;
+      }
+      CopyMem (NewBuffer, VariableName, VariableNameBufferSize);
+      if (VariableName != NULL) {
+        FreePool (VariableName);
+      }
+      VariableName = NewBuffer;
+      VariableNameBufferSize = VariableNameSize;
+
+      //
+      // Try to get the next variable name again with the larger buffer.
+      //
+      Status = gRT->GetNextVariableName (
+                      &VariableNameSize,
+                      VariableName,
+                      &VendorGuid
+                      );
+    }
+
+    if (EFI_ERROR (Status)) {
+      if (Status == EFI_NOT_FOUND) {
+        Status = EFI_SUCCESS;
+      }
+      break;
+    }
+
+    //
+    // Get the variable data and attributes
+    //
+    VariableDataSize = VariableDataBufferSize;
+    Status = gRT->GetVariable (
+                    VariableName,
+                    &VendorGuid,
+                    &VariableAttributes,
+                    &VariableDataSize,
+                    VariableData
+                    );
+    if (Status == EFI_BUFFER_TOO_SMALL) {
+      //
+      // The currently allocated VariableData buffer is too small,
+      // so we allocate a larger buffer.
+      //
+      if (VariableDataBufferSize != 0) {
+        FreePool (VariableData);
+        VariableData = NULL;
+        VariableDataBufferSize = 0;
+      }
+      VariableData = AllocatePool (VariableDataSize);
+      if (VariableData == NULL) {
+        Status = EFI_OUT_OF_RESOURCES;
+        break;
+      }
+      VariableDataBufferSize = VariableDataSize;
+
+      //
+      // Try to read the variable again with the larger buffer.
+      //
+      Status = gRT->GetVariable (
+                      VariableName,
+                      &VendorGuid,
+                      &VariableAttributes,
+                      &VariableDataSize,
+                      VariableData
+                      );
+    }
+    if (EFI_ERROR (Status)) {
+      break;
+    }
+
+    //
+    // Run the callback function
+    //
+    Status = (*CallbackFunction) (
+               Context,
+               VariableName,
+               &VendorGuid,
+               VariableAttributes,
+               VariableDataSize,
+               VariableData
+               );
+    if (EFI_ERROR (Status)) {
+      break;
+    }
+
+  }
+
+  if (VariableName != NULL) {
+    FreePool (VariableName);
+  }
+
+  if (VariableData != NULL) {
+    FreePool (VariableData);
+  }
+
+  return Status;
+}
+
+
+/**
+  Iterates all variables found in the variable serialization instance
+
+  @param[in]   Handle - Handle for a variable serialization instance
+  @param[in]   CallbackFunction - Function called for each variable instance
+  @param[in]   Context - Passed to each call of CallbackFunction
+
+  @retval      RETURN_SUCCESS - All variables were iterated without the
+                 CallbackFunction returning an error
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 iterate through the variables
+  @return      Any of RETURN_ERROR indicates an error reading the variable
+                 or an error was returned from CallbackFunction
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesIterateInstanceVariables (
+  IN EFI_HANDLE                                Handle,
+  IN VARIABLE_SERIALIZATION_ITERATION_CALLBACK CallbackFunction,
+  IN VOID                                      *Context
+  )
+{
+  SV_INSTANCE    *Instance;
+
+  Instance = SV_FROM_HANDLE (Handle);
+
+  if ((Instance->BufferPtr != NULL) && (Instance->DataSize != 0)) {
+    return IterateVariablesInBuffer (
+             CallbackFunction,
+             Context,
+             Instance->BufferPtr,
+             Instance->DataSize
+             );
+  } else {
+    return RETURN_SUCCESS;
+  }
+}
+
+
+/**
+  Sets all variables found in the variable serialization instance
+
+  @param[in]   Handle - Handle for a variable serialization instance
+
+  @retval      RETURN_SUCCESS - All variables were set successfully
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 set all the variables
+  @return      Any of RETURN_ERROR indicates an error reading the variables
+                 or in attempting to set a variable
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesSetSerializedVariables (
+  IN EFI_HANDLE                       Handle
+  )
+{
+  return SerializeVariablesIterateInstanceVariables (
+           Handle,
+           IterateVariablesCallbackSetSystemVariable,
+           NULL
+           );
+}
+
+
+/**
+  Adds a variable to the variable serialization instance
+
+  @param[in] Handle - Handle for a variable serialization instance
+  @param[in] VariableName - Refer to RuntimeServices GetVariable
+  @param[in] VendorGuid - Refer to RuntimeServices GetVariable
+  @param[in] Attributes - Refer to RuntimeServices GetVariable
+  @param[in] DataSize - Refer to RuntimeServices GetVariable
+  @param[in] Data - Refer to RuntimeServices GetVariable
+
+  @retval      RETURN_SUCCESS - All variables were set successfully
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 add the variable
+  @retval      RETURN_INVALID_PARAMETER - Handle was not a valid
+                 variable serialization instance or
+                 VariableName, VariableGuid or Data are NULL.
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesAddVariable (
+  IN EFI_HANDLE                   Handle,
+  IN CHAR16                       *VariableName,
+  IN EFI_GUID                     *VendorGuid,
+  IN UINT32                       Attributes,
+  IN UINTN                        DataSize,
+  IN VOID                         *Data
+  )
+{
+  RETURN_STATUS  Status;
+  SV_INSTANCE    *Instance;
+  UINT32         SerializedNameSize;
+  UINT32         SerializedDataSize;
+  UINTN          SerializedSize;
+
+  Instance = SV_FROM_HANDLE (Handle);
+
+  if ((Instance->Signature != SV_SIGNATURE) ||
+      (VariableName == NULL) || (VendorGuid == NULL) || (Data == NULL)) {
+  }
+
+  SerializedNameSize = (UINT32) StrSize (VariableName);
+
+  SerializedSize =
+    sizeof (SerializedNameSize) +
+    SerializedNameSize +
+    sizeof (*VendorGuid) +
+    sizeof (Attributes) +
+    sizeof (SerializedDataSize) +
+    DataSize;
+
+  Status = EnsureExtraBufferSpace (
+             Instance,
+             SerializedSize
+             );
+  if (RETURN_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Add name size (UINT32)
+  //
+  AppendToBuffer (Instance, (VOID*) &SerializedNameSize, sizeof (SerializedNameSize));
+
+  //
+  // Add variable unicode name string
+  //
+  AppendToBuffer (Instance, (VOID*) VariableName, SerializedNameSize);
+
+  //
+  // Add variable GUID
+  //
+  AppendToBuffer (Instance, (VOID*) VendorGuid, sizeof (*VendorGuid));
+
+  //
+  // Add variable attributes
+  //
+  AppendToBuffer (Instance, (VOID*) &Attributes, sizeof (Attributes));
+
+  //
+  // Add variable data size (UINT32)
+  //
+  SerializedDataSize = (UINT32) DataSize;
+  AppendToBuffer (Instance, (VOID*) &SerializedDataSize, sizeof (SerializedDataSize));
+
+  //
+  // Add variable data
+  //
+  AppendToBuffer (Instance, Data, DataSize);
+
+  return RETURN_SUCCESS;
+}
+
+
+/**
+  Serializes the variables known to this instance into the
+  provided buffer.
+
+  @param[in]     Handle - Handle for a variable serialization instance
+  @param[out]    Buffer - A buffer to store the binary representation
+                   of the variables.
+  @param[in,out] Size - On input this is the size of the buffer.
+                   On output this is the size of the binary representation
+                   of the variables.
+
+  @retval      RETURN_SUCCESS - The binary representation was successfully
+                 completed and returned in the buffer.
+  @retval      RETURN_OUT_OF_RESOURCES - There we not enough resources to
+                 save the variables to the buffer.
+  @retval      RETURN_INVALID_PARAMETER - Handle was not a valid
+                 variable serialization instance or
+                 Size or Buffer were NULL.
+  @retval      RETURN_BUFFER_TOO_SMALL - The Buffer size as indicated by
+                 the Size parameter was too small for the serialized
+                 variable data.  Size is returned with the required size.
+
+**/
+RETURN_STATUS
+EFIAPI
+SerializeVariablesToBuffer (
+  IN     EFI_HANDLE                       Handle,
+  OUT    VOID                             *Buffer,
+  IN OUT UINTN                            *Size
+  )
+{
+  SV_INSTANCE    *Instance;
+
+  Instance = SV_FROM_HANDLE (Handle);
+
+  if (Size == NULL) {
+    return RETURN_INVALID_PARAMETER;
+  }
+
+  if (*Size < Instance->DataSize) {
+    *Size = Instance->DataSize;
+    return RETURN_BUFFER_TOO_SMALL;
+  }
+
+  if (Buffer == NULL) {
+    return RETURN_INVALID_PARAMETER;
+  }
+
+  *Size = Instance->DataSize;
+  CopyMem (Buffer, Instance->BufferPtr, Instance->DataSize);
+
+  return RETURN_SUCCESS;
+}
+
diff --git a/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.h b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.h
new file mode 100644
index 0000000..4d01fd6
--- /dev/null
+++ b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.h
@@ -0,0 +1,39 @@
+/** @file
+  Serialize Variables Library implementation
+
+  Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef __SERIALIZE_VARIABLES_LIB_INSTANCE__
+#define __SERIALIZE_VARIABLES_LIB_INSTANCE__
+
+#include <Uefi.h>
+
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/SerializeVariablesLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+
+#define SV_FROM_HANDLE(a)       CR (a, SV_INSTANCE, Signature, SV_SIGNATURE)
+#define SV_SIGNATURE            SIGNATURE_32 ('S', 'V', 'A', 'R')
+
+typedef struct {
+  UINT32                              Signature;
+  VOID                                *BufferPtr;
+  UINTN                               BufferSize;
+  UINTN                               DataSize;
+} SV_INSTANCE;
+
+#endif
+
diff --git a/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.inf b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.inf
new file mode 100644
index 0000000..ec9dfbc
--- /dev/null
+++ b/corebootPkg/Library/SerializeVariablesLib/SerializeVariablesLib.inf
@@ -0,0 +1,41 @@
+## @file
+#  Serialize Variables Library implementation
+#
+#  This library serializes and deserializes UEFI variables
+#
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = DxeSerializeVariablesLib
+  FILE_GUID                      = 9515f92a-83ae-45fd-9d2e-e3dc15df52d0
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = SerializeVariablesLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER UEFI_DRIVER
+
+[Sources]
+  SerializeVariablesLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  corebootPkg/corebootPkg.dec
+  ShellPkg/ShellPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  MemoryAllocationLib
+  UefiBootServicesTableLib
+  UefiRuntimeServicesTableLib
+
diff --git a/corebootPkg/License.txt b/corebootPkg/License.txt
new file mode 100644
index 0000000..be68999
--- /dev/null
+++ b/corebootPkg/License.txt
@@ -0,0 +1,25 @@
+Copyright (c) 2012, Intel Corporation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+* Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
diff --git a/corebootPkg/PlatformPei/Coreboot.h b/corebootPkg/PlatformPei/Coreboot.h
new file mode 100644
index 0000000..1941a62
--- /dev/null
+++ b/corebootPkg/PlatformPei/Coreboot.h
@@ -0,0 +1,190 @@
+/** @file
+  Coreboot PEI module include file.
+
+  Copyright (c) 2013, Google Inc. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _COREBOOT_PEI_H_INCLUDED_
+#define _COREBOOT_PEI_H_INCLUDED_
+
+struct cbuint64 {
+  UINT32 lo;
+  UINT32 hi;
+};
+
+struct cb_header {
+  UINT32 signature;
+  UINT32 header_bytes;
+  UINT32 header_checksum;
+  UINT32 table_bytes;
+  UINT32 table_checksum;
+  UINT32 table_entries;
+};
+
+struct cb_record {
+  UINT32 tag;
+  UINT32 size;
+};
+
+#define CB_TAG_UNUSED     0x0000
+#define CB_TAG_MEMORY     0x0001
+
+struct cb_memory_range {
+  struct cbuint64 start;
+  struct cbuint64 size;
+  UINT32 type;
+};
+
+#define CB_MEM_RAM    1
+#define CB_MEM_RESERVED     2
+#define CB_MEM_ACPI   3
+#define CB_MEM_NVS    4
+#define CB_MEM_UNUSABLE     5
+#define CB_MEM_VENDOR_RSVD  6
+#define CB_MEM_TABLE       16
+
+struct cb_memory {
+  UINT32 tag;
+  UINT32 size;
+  struct cb_memory_range map[0];
+};
+
+#define CB_TAG_MAINBOARD  0x0003
+
+struct cb_mainboard {
+  UINT32 tag;
+  UINT32 size;
+  UINT8 vendor_idx;
+  UINT8 part_number_idx;
+  UINT8 strings[0];
+};
+#define CB_TAG_VERSION  0x0004
+#define CB_TAG_EXTRA_VERSION  0x0005
+#define CB_TAG_BUILD    0x0006
+#define CB_TAG_COMPILE_TIME   0x0007
+#define CB_TAG_COMPILE_BY     0x0008
+#define CB_TAG_COMPILE_HOST   0x0009
+#define CB_TAG_COMPILE_DOMAIN 0x000a
+#define CB_TAG_COMPILER       0x000b
+#define CB_TAG_LINKER   0x000c
+#define CB_TAG_ASSEMBLER      0x000d
+
+struct cb_string {
+  UINT32 tag;
+  UINT32 size;
+  UINT8 string[0];
+};
+
+#define CB_TAG_SERIAL   0x000f
+
+struct cb_serial {
+  UINT32 tag;
+  UINT32 size;
+#define CB_SERIAL_TYPE_IO_MAPPED     1
+#define CB_SERIAL_TYPE_MEMORY_MAPPED 2
+  UINT32 type;
+  UINT32 baseaddr;
+  UINT32 baud;
+};
+
+#define CB_TAG_CONSOLE       0x00010
+
+struct cb_console {
+  UINT32 tag;
+  UINT32 size;
+  UINT16 type;
+};
+
+#define CB_TAG_CONSOLE_SERIAL8250 0
+#define CB_TAG_CONSOLE_VGA  1 // OBSOLETE
+#define CB_TAG_CONSOLE_BTEXT      2 // OBSOLETE
+#define CB_TAG_CONSOLE_LOGBUF     3
+#define CB_TAG_CONSOLE_SROM       4 // OBSOLETE
+#define CB_TAG_CONSOLE_EHCI       5
+
+#define CB_TAG_FORWARD       0x00011
+
+struct cb_forward {
+  UINT32 tag;
+  UINT32 size;
+  UINT64 forward;
+};
+
+#define CB_TAG_FRAMEBUFFER      0x0012
+struct cb_framebuffer {
+  UINT32 tag;
+  UINT32 size;
+
+  UINT64 physical_address;
+  UINT32 x_resolution;
+  UINT32 y_resolution;
+  UINT32 bytes_per_line;
+  UINT8 bits_per_pixel;
+  UINT8 red_mask_pos;
+  UINT8 red_mask_size;
+  UINT8 green_mask_pos;
+  UINT8 green_mask_size;
+  UINT8 blue_mask_pos;
+  UINT8 blue_mask_size;
+  UINT8 reserved_mask_pos;
+  UINT8 reserved_mask_size;
+};
+
+#define CB_TAG_VDAT     0x0015
+struct cb_vdat {
+  UINT32 tag;
+  UINT32 size;  /* size of the entire entry */
+  UINT64 vdat_addr;
+  UINT32 vdat_size;
+};
+
+#define CB_TAG_TIMESTAMPS       0x0016
+#define CB_TAG_CBMEM_CONSOLE    0x0017
+#define CB_TAG_MRC_CACHE  0x0018
+struct cb_cbmem_tab {
+  UINT32 tag;
+  UINT32 size;
+  UINT64 cbmem_tab;
+};
+
+/* Helpful inlines */
+
+static inline UINT64 cb_unpack64(struct cbuint64 val)
+{
+  return (((UINT64) val.hi) << 32) | val.lo;
+}
+
+static inline const char *cb_mb_vendor_string(const struct cb_mainboard *cbm)
+{
+  return (char *)(cbm->strings + cbm->vendor_idx);
+}
+
+static inline const char *cb_mb_part_string(const struct cb_mainboard *cbm)
+{
+  return (char *)(cbm->strings + cbm->part_number_idx);
+}
+
+/* Helpful macros */
+
+#define MEM_RANGE_COUNT(_rec) \
+  (((_rec)->size - sizeof(*(_rec))) / sizeof((_rec)->map[0]))
+
+#define MEM_RANGE_PTR(_rec, _idx) \
+  (void *)(((UINT8 *) (_rec)) + sizeof(*(_rec)) \
+    + (sizeof((_rec)->map[0]) * (_idx)))
+
+
+VOID
+FindCorebootTable (
+  VOID
+  );
+
+#endif // _COREBOOT_PEI_H_INCLUDED_
diff --git a/corebootPkg/PlatformPei/Fv.c b/corebootPkg/PlatformPei/Fv.c
new file mode 100644
index 0000000..687c88c
--- /dev/null
+++ b/corebootPkg/PlatformPei/Fv.c
@@ -0,0 +1,58 @@
+/** @file
+  Build FV related hobs for platform.
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "PiPei.h"
+#include <Library/DebugLib.h>
+#include <Library/HobLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/PcdLib.h>
+
+
+/**
+  Perform a call-back into the SEC simulator to get address of the Firmware Hub
+
+  @param  FfsHeader     Ffs Header availible to every PEIM
+  @param  PeiServices   General purpose services available to every PEIM.
+
+  @retval EFI_SUCCESS   Platform PEI FVs were initialized successfully.
+
+**/
+EFI_STATUS
+PeiFvInitialization (
+  VOID
+  )
+{
+  DEBUG ((EFI_D_ERROR, "Platform PEI Firmware Volume Initialization\n"));
+
+  DEBUG (
+    (EFI_D_ERROR, "Firmware Volume HOB: 0x%x 0x%x\n",
+      PcdGet32 (PcdCorebootMemFvBase),
+      PcdGet32 (PcdCorebootMemFvSize)
+      )
+    );
+
+  BuildFvHob (PcdGet32 (PcdCorebootMemFvBase), PcdGet32 (PcdCorebootMemFvSize));
+
+  //
+  // Create a memory allocation HOB.
+  //
+  BuildMemoryAllocationHob (
+    PcdGet32 (PcdCorebootMemFvBase),
+    PcdGet32 (PcdCorebootMemFvSize),
+    EfiBootServicesData
+    );
+
+  return EFI_SUCCESS;
+}
+
diff --git a/corebootPkg/PlatformPei/MemDetect.c b/corebootPkg/PlatformPei/MemDetect.c
new file mode 100644
index 0000000..22b6b64
--- /dev/null
+++ b/corebootPkg/PlatformPei/MemDetect.c
@@ -0,0 +1,174 @@
+/**@file
+  Memory Detection for Virtual Machines.
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+Module Name:
+
+  MemDetect.c
+
+**/
+
+//
+// The package level header files this module uses
+//
+#include <PiPei.h>
+
+//
+// The Library classes this module consumes
+//
+#include <Library/DebugLib.h>
+#include <Library/HobLib.h>
+#include <Library/IoLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PeimEntryPoint.h>
+#include <Library/ResourcePublicationLib.h>
+#include <Library/MtrrLib.h>
+
+#include "Platform.h"
+#include "Coreboot.h"
+
+UINT64                      LowerMemorySize;
+UINT64                      UpperMemorySize;
+
+VOID
+ParseMemory(
+  struct cb_memory *rec
+  )
+{
+  int i;
+
+  DEBUG ((EFI_D_ERROR, "Found memory information\n"));
+  LowerMemorySize = 0;
+  UpperMemorySize = 0;
+
+  for (i=0; i< MEM_RANGE_COUNT(rec); i++) {
+    struct cb_memory_range *range = MEM_RANGE_PTR(rec, i);
+    UINT64 start, size;
+    start = cb_unpack64(range->start);
+    size = cb_unpack64(range->size);
+    DEBUG ((EFI_D_ERROR, "%d. %016lx - %016lx [%02x]\n",
+      i, start, start + size - 1, range->type));
+    if (range->type != CB_MEM_RAM)
+      continue;
+    if (start + size < 0x100000000ULL) {
+      LowerMemorySize = start + size;
+    } else {
+      UpperMemorySize = start + size - 0x100000000ULL;
+    }
+  }
+}
+
+VOID
+FindTableAt (
+  VOID *addr
+  )
+{
+  struct cb_header *header;
+  unsigned char *ptr = addr;
+  int i, len=4096;
+
+  for (i = 0; i < len; i += 16, ptr += 16) {
+    header = (struct cb_header *)ptr;
+    if (header->signature == 0x4f49424c) {
+      break;
+    }
+  }
+  
+  if (i >= len)
+    return;
+
+  if (!header->table_bytes)
+    return;
+
+  DEBUG ((EFI_D_ERROR, "Found coreboot table at %p.\n", header));
+  ptr += header->header_bytes;
+  for (i = 0; i < header->table_entries; i++) {
+    struct cb_record *rec = (struct cb_record *)ptr;
+    switch (rec->tag) {
+    case CB_TAG_FORWARD:
+      FindTableAt((void *)(unsigned long)((struct cb_forward *)rec)->forward);
+      return;
+    case CB_TAG_MEMORY:
+      ParseMemory((struct cb_memory *)ptr);
+      break;
+    default:
+      break;
+    }
+    ptr += rec->size;
+  }
+}
+
+VOID
+FindCorebootTable (
+  VOID
+  )
+{
+  FindTableAt((void *)0);
+}
+
+/**
+  Peform Memory Detection
+
+  @return EFI_SUCCESS     The PEIM initialized successfully.
+
+**/
+
+EFI_PHYSICAL_ADDRESS
+MemDetect (
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_PHYSICAL_ADDRESS        MemoryBase;
+  UINT64                      MemorySize;
+
+  DEBUG ((EFI_D_ERROR, "MemDetect called\n"));
+
+  //
+  // Total memory size available detected by coreboot table
+  //
+  FindCorebootTable();
+
+  //
+  // Determine the range of memory to use during PEI
+  //
+  MemoryBase = PcdGet32 (PcdCorebootMemFvBase) + PcdGet32 (PcdCorebootMemFvSize);
+  MemorySize = LowerMemorySize - MemoryBase;
+  if (MemorySize > SIZE_64MB) {
+    MemoryBase = LowerMemorySize - SIZE_64MB;
+    MemorySize = SIZE_64MB;
+  }
+
+  //
+  // Publish this memory to the PEI Core
+  //
+  Status = PublishSystemMemory(MemoryBase, MemorySize);
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Create memory HOBs
+  //
+  AddMemoryBaseSizeHob (MemoryBase, MemorySize);
+  AddMemoryRangeHob (BASE_1MB, MemoryBase);
+  AddMemoryRangeHob (0, BASE_512KB + BASE_128KB);
+
+  MtrrSetMemoryAttribute (BASE_1MB, MemoryBase + MemorySize - BASE_1MB, CacheWriteBack);
+
+  MtrrSetMemoryAttribute (0, BASE_512KB + BASE_128KB, CacheWriteBack);
+
+  if (UpperMemorySize != 0) {
+    AddUntestedMemoryBaseSizeHob (BASE_4GB, UpperMemorySize);
+
+    MtrrSetMemoryAttribute (BASE_4GB, UpperMemorySize, CacheWriteBack);
+  }
+
+  return MemoryBase + MemorySize;
+}
+
diff --git a/corebootPkg/PlatformPei/Platform.c b/corebootPkg/PlatformPei/Platform.c
new file mode 100644
index 0000000..c310387
--- /dev/null
+++ b/corebootPkg/PlatformPei/Platform.c
@@ -0,0 +1,302 @@
+/**@file
+  Platform PEI driver
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2011, Andrei Warkentin <andreiw@motorola.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+//
+// The package level header files this module uses
+//
+#include <PiPei.h>
+
+//
+// The Library classes this module consumes
+//
+#include <Library/DebugLib.h>
+#include <Library/HobLib.h>
+#include <Library/IoLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PciLib.h>
+#include <Library/PeimEntryPoint.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/ResourcePublicationLib.h>
+#include <Guid/MemoryTypeInformation.h>
+#include <Ppi/MasterBootMode.h>
+#include <IndustryStandard/Pci22.h>
+
+#include "Platform.h"
+
+EFI_MEMORY_TYPE_INFORMATION mDefaultMemoryTypeInformation[] = {
+  { EfiACPIMemoryNVS,       0x004 },
+  { EfiACPIReclaimMemory,   0x008 },
+  { EfiReservedMemoryType,  0x004 },
+  { EfiRuntimeServicesData, 0x024 },
+  { EfiRuntimeServicesCode, 0x030 },
+  { EfiBootServicesCode,    0x180 },
+  { EfiBootServicesData,    0xF00 },
+  { EfiMaxMemoryType,       0x000 }
+};
+
+
+EFI_PEI_PPI_DESCRIPTOR   mPpiBootMode[] = {
+  {
+    EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST,
+    &gEfiPeiMasterBootModePpiGuid,
+    NULL
+  }
+};
+
+
+VOID
+AddIoMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  )
+{
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_MEMORY_MAPPED_IO,
+      EFI_RESOURCE_ATTRIBUTE_PRESENT     |
+      EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+      EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_TESTED,
+    MemoryBase,
+    MemorySize
+    );
+}
+
+VOID
+AddReservedMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  )
+{
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_MEMORY_RESERVED,
+      EFI_RESOURCE_ATTRIBUTE_PRESENT     |
+      EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+      EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_TESTED,
+    MemoryBase,
+    MemorySize
+    );
+}
+
+VOID
+AddIoMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  )
+{
+  AddIoMemoryBaseSizeHob (MemoryBase, (UINT64)(MemoryLimit - MemoryBase));
+}
+
+
+VOID
+AddMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  )
+{
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_SYSTEM_MEMORY,
+      EFI_RESOURCE_ATTRIBUTE_PRESENT |
+      EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+      EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_TESTED,
+    MemoryBase,
+    MemorySize
+    );
+}
+
+
+VOID
+AddMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  )
+{
+  AddMemoryBaseSizeHob (MemoryBase, (UINT64)(MemoryLimit - MemoryBase));
+}
+
+
+VOID
+AddUntestedMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  )
+{
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_SYSTEM_MEMORY,
+      EFI_RESOURCE_ATTRIBUTE_PRESENT |
+      EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+      EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE |
+      EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE,
+    MemoryBase,
+    MemorySize
+    );
+}
+
+
+VOID
+AddUntestedMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  )
+{
+  AddUntestedMemoryBaseSizeHob (MemoryBase, (UINT64)(MemoryLimit - MemoryBase));
+}
+
+
+VOID
+MemMapInitialization (
+  EFI_PHYSICAL_ADDRESS  TopOfMemory
+  )
+{
+  //
+  // Create Memory Type Information HOB
+  //
+  BuildGuidDataHob (
+    &gEfiMemoryTypeInformationGuid,
+    mDefaultMemoryTypeInformation,
+    sizeof(mDefaultMemoryTypeInformation)
+    );
+
+  //
+  // Add PCI IO Port space available for PCI resource allocations.
+  //
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_IO,
+    EFI_RESOURCE_ATTRIBUTE_PRESENT     |
+    EFI_RESOURCE_ATTRIBUTE_INITIALIZED,
+    0xC000,
+    0x4000
+    );
+
+  //
+  // Video memory + Legacy BIOS region
+  //
+  AddIoMemoryRangeHob (0x0A0000, BASE_1MB);
+
+  //
+  // address       purpose   size
+  // ------------  --------  -------------------------
+  // max(top, 2g)  PCI MMIO  0xFC000000 - max(top, 2g)
+  // 0xFC000000    gap                           44 MB
+  // 0xFEC00000    IO-APIC                        4 KB
+  // 0xFEC01000    gap                         1020 KB
+  // 0xFED00000    HPET                           1 KB
+  // 0xFED00400    gap                         1023 KB
+  // 0xFEE00000    LAPIC                          1 MB
+  //
+  AddIoMemoryRangeHob (TopOfMemory < BASE_2GB ? BASE_2GB : TopOfMemory, 0xFC000000);
+  AddIoMemoryBaseSizeHob (0xFEC00000, SIZE_4KB);
+  AddIoMemoryBaseSizeHob (0xFED00000, SIZE_1KB);
+  AddIoMemoryBaseSizeHob (PcdGet32(PcdCpuLocalApicBaseAddress), SIZE_1MB);
+}
+
+
+VOID
+MiscInitialization (
+  VOID
+  )
+{
+  //
+  // Disable A20 Mask
+  //
+  IoOr8 (0x92, BIT1);
+
+  //
+  // Build the CPU hob with 36-bit addressing and 16-bits of IO space.
+  //
+  BuildCpuHob (36, 16);
+}
+
+
+VOID
+BootModeInitialization (
+  )
+{
+  EFI_STATUS Status;
+
+  Status = PeiServicesSetBootMode (BOOT_WITH_FULL_CONFIGURATION);
+  ASSERT_EFI_ERROR (Status);
+
+  Status = PeiServicesInstallPpi (mPpiBootMode);
+  ASSERT_EFI_ERROR (Status);
+}
+
+
+VOID
+ReserveEmuVariableNvStore (
+  )
+{
+  EFI_PHYSICAL_ADDRESS VariableStore;
+
+  //
+  // Allocate storage for NV variables early on so it will be
+  // at a consistent address.  Since VM memory is preserved
+  // across reboots, this allows the NV variable storage to survive
+  // a VM reboot.
+  //
+  VariableStore =
+    (EFI_PHYSICAL_ADDRESS)(UINTN)
+      AllocateRuntimePool (
+        2 * PcdGet32 (PcdFlashNvStorageFtwSpareSize)
+        );
+  DEBUG ((EFI_D_INFO,
+          "Reserved variable store memory: 0x%lX; size: %dkb\n",
+          VariableStore,
+          (2 * PcdGet32 (PcdFlashNvStorageFtwSpareSize)) / 1024
+        ));
+  PcdSet64 (PcdEmuVariableNvStoreReserved, VariableStore);
+}
+
+
+/**
+  Perform Platform PEI initialization.
+
+  @param  FileHandle      Handle of the file being invoked.
+  @param  PeiServices     Describes the list of possible PEI Services.
+
+  @return EFI_SUCCESS     The PEIM initialized successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializePlatform (
+  IN       EFI_PEI_FILE_HANDLE  FileHandle,
+  IN CONST EFI_PEI_SERVICES     **PeiServices
+  )
+{
+  EFI_PHYSICAL_ADDRESS  TopOfMemory;
+
+  DEBUG ((EFI_D_ERROR, "Platform PEIM Loaded\n"));
+
+  TopOfMemory = MemDetect ();
+
+  PeiFvInitialization ();
+
+  MemMapInitialization (TopOfMemory);
+
+  MiscInitialization ();
+
+  BootModeInitialization ();
+
+  return EFI_SUCCESS;
+}
diff --git a/corebootPkg/PlatformPei/Platform.h b/corebootPkg/PlatformPei/Platform.h
new file mode 100644
index 0000000..953a2e9
--- /dev/null
+++ b/corebootPkg/PlatformPei/Platform.h
@@ -0,0 +1,70 @@
+/** @file
+  Platform PEI module include file.
+
+  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _PLATFORM_PEI_H_INCLUDED_
+#define _PLATFORM_PEI_H_INCLUDED_
+
+VOID
+AddIoMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  );
+
+VOID
+AddIoMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  );
+
+VOID
+AddMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  );
+
+VOID
+AddMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  );
+
+VOID
+AddUntestedMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  );
+
+VOID
+AddReservedMemoryBaseSizeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  UINT64                      MemorySize
+  );
+
+VOID
+AddUntestedMemoryRangeHob (
+  EFI_PHYSICAL_ADDRESS        MemoryBase,
+  EFI_PHYSICAL_ADDRESS        MemoryLimit
+  );
+
+EFI_PHYSICAL_ADDRESS
+MemDetect (
+  VOID
+  );
+
+EFI_STATUS
+PeiFvInitialization (
+  VOID
+  );
+
+#endif // _PLATFORM_PEI_H_INCLUDED_
diff --git a/corebootPkg/PlatformPei/PlatformPei.inf b/corebootPkg/PlatformPei/PlatformPei.inf
new file mode 100644
index 0000000..434dd74
--- /dev/null
+++ b/corebootPkg/PlatformPei/PlatformPei.inf
@@ -0,0 +1,71 @@
+## @file
+#  Platform PEI driver
+#
+#  This module provides platform specific function to detect boot mode.
+#  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformPei
+  FILE_GUID                      = 222c386d-5abc-4fb4-b124-fbb82488acf4
+  MODULE_TYPE                    = PEIM
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = InitializePlatform
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  Fv.c
+  MemDetect.c
+  Platform.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+  corebootPkg/corebootPkg.dec
+
+[Guids]
+  gEfiMemoryTypeInformationGuid
+
+[LibraryClasses]
+  DebugLib
+  HobLib
+  IoLib
+  PciLib
+  PeiResourcePublicationLib
+  PeiServicesLib
+  PeiServicesTablePointerLib
+  PeimEntryPoint
+  MtrrLib
+  PcdLib
+
+[Pcd]
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvBase
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvStoreReserved
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuLocalApicBaseAddress
+
+[Ppis]
+  gEfiPeiMasterBootModePpiGuid
+
+[Depex]
+  TRUE
+
diff --git a/corebootPkg/Sec/Ia32/SecEntry.S b/corebootPkg/Sec/Ia32/SecEntry.S
new file mode 100644
index 0000000..6410875
--- /dev/null
+++ b/corebootPkg/Sec/Ia32/SecEntry.S
@@ -0,0 +1,55 @@
+#      TITLE   SecEntry.asm
+#------------------------------------------------------------------------------
+#*
+#*   Copyright (c) 2006 - 2009, Intel Corporation. All rights reserved.<BR>
+#*                 2013 Patrick Georgi
+#*   This program and the accompanying materials
+#*   are licensed and made available under the terms and conditions of the BSD License
+#*   which accompanies this distribution.  The full text of the license may be found at
+#*   http://opensource.org/licenses/bsd-license.php
+#*
+#*   THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#*   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#*
+#*    CpuAsm.asm
+#*
+#*   Abstract:
+#*
+#------------------------------------------------------------------------------
+
+
+#include <Base.h>
+#include <Library/PcdLib.h>
+
+#EXTERN ASM_PFX(SecCoreStartupWithStack)
+
+#
+# SecCore Entry Point
+#
+# Processor is in flat protected mode
+#
+# @return     None  This routine does not return
+#
+ASM_GLOBAL ASM_PFX(_ModuleEntryPoint)
+ASM_PFX(_ModuleEntryPoint):
+
+    #
+    # Load temporary stack top at very low memory.  The C code
+    # can reload to a better address.
+    # Also load the base address of SECFV.
+    #
+    movl    $BASE_512KB, %eax 
+    movl    $FixedPcdGet32(PcdCorebootMemFvBase), %ebp
+    movl    %eax, %esp
+    nop
+
+    #
+    # Call into C code
+    #
+    pushl   %eax
+    pushl   %ebp
+    call    ASM_PFX(SecCoreStartupWithStack)
+
+
+#END
+
diff --git a/corebootPkg/Sec/SecMain.c b/corebootPkg/Sec/SecMain.c
new file mode 100644
index 0000000..ca26136
--- /dev/null
+++ b/corebootPkg/Sec/SecMain.c
@@ -0,0 +1,655 @@
+/** @file
+  Main SEC phase code.  Transitions to PEI.
+
+  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <PiPei.h>
+
+#include <Library/PeimEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/PcdLib.h>
+#include <Library/UefiCpuLib.h>
+#include <Library/DebugAgentLib.h>
+#include <Library/IoLib.h>
+#include <Library/PeCoffLib.h>
+#include <Library/PeCoffGetEntryPointLib.h>
+#include <Library/PeCoffExtraActionLib.h>
+
+#include <Ppi/TemporaryRamSupport.h>
+
+#define SEC_IDT_ENTRY_COUNT  34
+
+typedef struct _SEC_IDT_TABLE {
+  EFI_PEI_SERVICES          *PeiService;
+  IA32_IDT_GATE_DESCRIPTOR  IdtTable[SEC_IDT_ENTRY_COUNT];
+} SEC_IDT_TABLE;
+
+VOID
+EFIAPI
+SecStartupPhase2 (
+  IN VOID                     *Context
+  );
+
+EFI_STATUS
+EFIAPI
+TemporaryRamMigration (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  );
+
+//
+//
+//  
+EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI mTemporaryRamSupportPpi = {
+  TemporaryRamMigration
+};
+
+EFI_PEI_PPI_DESCRIPTOR mPrivateDispatchTable[] = {
+  {
+    (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
+    &gEfiTemporaryRamSupportPpiGuid,
+    &mTemporaryRamSupportPpi
+  },
+};
+
+//
+// Template of an IDT entry pointing to 10:FFFFFFE4h.
+//
+IA32_IDT_GATE_DESCRIPTOR  mIdtEntryTemplate = {
+  {                                      // Bits
+    0xffe4,                              // OffsetLow
+    0x10,                                // Selector
+    0x0,                                 // Reserved_0
+    IA32_IDT_GATE_TYPE_INTERRUPT_32,     // GateType
+    0xffff                               // OffsetHigh
+  }    
+};
+
+/**
+  Locates the main boot firmware volume.
+
+  @param[in,out]  BootFv  On input, the base of the BootFv
+                          On output, the decompressed main firmware volume
+
+  @retval EFI_SUCCESS    The main firmware volume was located and decompressed
+  @retval EFI_NOT_FOUND  The main firmware volume was not found
+
+**/
+EFI_STATUS
+FindMainFv (
+  IN OUT  EFI_FIRMWARE_VOLUME_HEADER   **BootFv
+  )
+{
+  EFI_FIRMWARE_VOLUME_HEADER  *Fv;
+
+  ASSERT (((UINTN) *BootFv & EFI_PAGE_MASK) == 0);
+
+  Fv = *BootFv;
+  Fv = (EFI_FIRMWARE_VOLUME_HEADER*) ((UINT8*) Fv + (UINTN) Fv->FvLength);
+  ASSERT(Fv->Signature == EFI_FVH_SIGNATURE);
+  *BootFv = Fv;
+  return EFI_SUCCESS;
+}
+
+/**
+  Locates a section within a series of sections
+  with the specified section type.
+
+  @param[in]   Sections        The sections to search
+  @param[in]   SizeOfSections  Total size of all sections
+  @param[in]   SectionType     The section type to locate
+  @param[out]  FoundSection    The FFS section if found
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+FindFfsSectionInSections (
+  IN  VOID                             *Sections,
+  IN  UINTN                            SizeOfSections,
+  IN  EFI_SECTION_TYPE                 SectionType,
+  OUT EFI_COMMON_SECTION_HEADER        **FoundSection
+  )
+{
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfSections;
+  EFI_COMMON_SECTION_HEADER   *Section;
+  EFI_PHYSICAL_ADDRESS        EndOfSection;
+
+  //
+  // Loop through the FFS file sections within the PEI Core FFS file
+  //
+  EndOfSection = (EFI_PHYSICAL_ADDRESS)(UINTN) Sections;
+  EndOfSections = EndOfSection + SizeOfSections;
+  for (;;) {
+    if (EndOfSection == EndOfSections) {
+      break;
+    }
+    CurrentAddress = (EndOfSection + 3) & ~(3ULL);
+    if (CurrentAddress >= EndOfSections) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    Section = (EFI_COMMON_SECTION_HEADER*)(UINTN) CurrentAddress;
+    DEBUG ((EFI_D_INFO, "Section->Type: 0x%x\n", Section->Type));
+
+    Size = SECTION_SIZE (Section);
+    if (Size < sizeof (*Section)) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    EndOfSection = CurrentAddress + Size;
+    if (EndOfSection > EndOfSections) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    //
+    // Look for the requested section type
+    //
+    if (Section->Type == SectionType) {
+      *FoundSection = Section;
+      return EFI_SUCCESS;
+    }
+    DEBUG ((EFI_D_INFO, "Section->Type (0x%x) != SectionType (0x%x)\n", Section->Type, SectionType));
+  }
+
+  return EFI_NOT_FOUND;
+}
+
+/**
+  Locates a FFS file with the specified file type and a section
+  within that file with the specified section type.
+
+  @param[in]   Fv            The firmware volume to search
+  @param[in]   FileType      The file type to locate
+  @param[in]   SectionType   The section type to locate
+  @param[out]  FoundSection  The FFS section if found
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+EFIAPI
+FindFfsFileAndSection (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *Fv,
+  IN  EFI_FV_FILETYPE                  FileType,
+  IN  EFI_SECTION_TYPE                 SectionType,
+  OUT EFI_COMMON_SECTION_HEADER        **FoundSection
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  EFI_PHYSICAL_ADDRESS        EndOfFirmwareVolume;
+  EFI_FFS_FILE_HEADER         *File;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfFile;
+
+  if (Fv->Signature != EFI_FVH_SIGNATURE) {
+    DEBUG ((EFI_D_INFO, "FV at %p does not have FV header signature\n", Fv));
+    return EFI_VOLUME_CORRUPTED;
+  }
+
+  CurrentAddress = (EFI_PHYSICAL_ADDRESS)(UINTN) Fv;
+  EndOfFirmwareVolume = CurrentAddress + Fv->FvLength;
+
+  //
+  // Loop through the FFS files in the Boot Firmware Volume
+  //
+  for (EndOfFile = CurrentAddress + Fv->HeaderLength; ; ) {
+
+    CurrentAddress = (EndOfFile + 7) & ~(7ULL);
+    if (CurrentAddress > EndOfFirmwareVolume) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    File = (EFI_FFS_FILE_HEADER*)(UINTN) CurrentAddress;
+    Size = *(UINT32*) File->Size & 0xffffff;
+    if (Size < (sizeof (*File) + sizeof (EFI_COMMON_SECTION_HEADER))) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+    DEBUG ((EFI_D_INFO, "File->Type: 0x%x\n", File->Type));
+
+    EndOfFile = CurrentAddress + Size;
+    if (EndOfFile > EndOfFirmwareVolume) {
+      return EFI_VOLUME_CORRUPTED;
+    }
+
+    //
+    // Look for the request file type
+    //
+    if (File->Type != FileType) {
+      DEBUG ((EFI_D_INFO, "File->Type (0x%x) != FileType (0x%x)\n", File->Type, FileType));
+      continue;
+    }
+
+    Status = FindFfsSectionInSections (
+               (VOID*) (File + 1),
+               (UINTN) EndOfFile - (UINTN) (File + 1),
+               SectionType,
+               FoundSection
+               );
+    if (!EFI_ERROR (Status) || (Status == EFI_VOLUME_CORRUPTED)) {
+      return Status;
+    }
+  }
+}
+
+/**
+  Locates the PEI Core entry point address
+
+  @param[in]  Fv                 The firmware volume to search
+  @param[out] PeiCoreEntryPoint  The entry point of the PEI Core image
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+EFI_STATUS
+EFIAPI
+FindPeiCoreImageBaseInFv (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *Fv,
+  OUT  EFI_PHYSICAL_ADDRESS             *PeiCoreImageBase
+  )
+{
+  EFI_STATUS                  Status;
+  EFI_COMMON_SECTION_HEADER   *Section;
+
+  Status = FindFfsFileAndSection (
+             Fv,
+             EFI_FV_FILETYPE_PEI_CORE,
+             EFI_SECTION_PE32,
+             &Section
+             );
+  if (EFI_ERROR (Status)) {
+    Status = FindFfsFileAndSection (
+               Fv,
+               EFI_FV_FILETYPE_PEI_CORE,
+               EFI_SECTION_TE,
+               &Section
+               );
+    if (EFI_ERROR (Status)) {
+      DEBUG ((EFI_D_ERROR, "Unable to find PEI Core image\n"));
+      return Status;
+    }
+  }
+
+  *PeiCoreImageBase = (EFI_PHYSICAL_ADDRESS)(UINTN)(Section + 1);
+  return EFI_SUCCESS;
+}
+
+/**
+  Locates the PEI Core entry point address
+
+  @param[in,out]  Fv                 The firmware volume to search
+  @param[out]     PeiCoreEntryPoint  The entry point of the PEI Core image
+
+  @retval EFI_SUCCESS           The file and section was found
+  @retval EFI_NOT_FOUND         The file and section was not found
+  @retval EFI_VOLUME_CORRUPTED  The firmware volume was corrupted
+
+**/
+VOID
+EFIAPI
+FindPeiCoreImageBase (
+  IN OUT  EFI_FIRMWARE_VOLUME_HEADER       **BootFv,
+     OUT  EFI_PHYSICAL_ADDRESS             *PeiCoreImageBase
+  )
+{
+  *PeiCoreImageBase = 0;
+
+  FindMainFv (BootFv);
+
+  FindPeiCoreImageBaseInFv (*BootFv, PeiCoreImageBase);
+}
+
+/**
+  Find core image base.
+
+**/
+EFI_STATUS
+EFIAPI
+FindImageBase (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       *BootFirmwareVolumePtr,
+  OUT EFI_PHYSICAL_ADDRESS             *SecCoreImageBase
+  )
+{
+  EFI_PHYSICAL_ADDRESS        CurrentAddress;
+  EFI_PHYSICAL_ADDRESS        EndOfFirmwareVolume;
+  EFI_FFS_FILE_HEADER         *File;
+  UINT32                      Size;
+  EFI_PHYSICAL_ADDRESS        EndOfFile;
+  EFI_COMMON_SECTION_HEADER   *Section;
+  EFI_PHYSICAL_ADDRESS        EndOfSection;
+
+  *SecCoreImageBase = 0;
+
+  CurrentAddress = (EFI_PHYSICAL_ADDRESS)(UINTN) BootFirmwareVolumePtr;
+  EndOfFirmwareVolume = CurrentAddress + BootFirmwareVolumePtr->FvLength;
+
+  //
+  // Loop through the FFS files in the Boot Firmware Volume
+  //
+  for (EndOfFile = CurrentAddress + BootFirmwareVolumePtr->HeaderLength; ; ) {
+
+    CurrentAddress = (EndOfFile + 7) & 0xfffffffffffffff8ULL;
+    if (CurrentAddress > EndOfFirmwareVolume) {
+      return EFI_NOT_FOUND;
+    }
+
+    File = (EFI_FFS_FILE_HEADER*)(UINTN) CurrentAddress;
+    Size = *(UINT32*) File->Size & 0xffffff;
+    if (Size < sizeof (*File)) {
+      return EFI_NOT_FOUND;
+    }
+
+    EndOfFile = CurrentAddress + Size;
+    if (EndOfFile > EndOfFirmwareVolume) {
+      return EFI_NOT_FOUND;
+    }
+
+    //
+    // Look for SEC Core
+    //
+    if (File->Type != EFI_FV_FILETYPE_SECURITY_CORE) {
+      continue;
+    }
+
+    //
+    // Loop through the FFS file sections within the FFS file
+    //
+    EndOfSection = (EFI_PHYSICAL_ADDRESS)(UINTN) (File + 1);
+    for (;;) {
+      CurrentAddress = (EndOfSection + 3) & 0xfffffffffffffffcULL;
+      Section = (EFI_COMMON_SECTION_HEADER*)(UINTN) CurrentAddress;
+
+      Size = *(UINT32*) Section->Size & 0xffffff;
+      if (Size < sizeof (*Section)) {
+        return EFI_NOT_FOUND;
+      }
+
+      EndOfSection = CurrentAddress + Size;
+      if (EndOfSection > EndOfFile) {
+        return EFI_NOT_FOUND;
+      }
+
+      //
+      // Look for executable sections
+      //
+      if (Section->Type == EFI_SECTION_PE32 || Section->Type == EFI_SECTION_TE) {
+        if (File->Type == EFI_FV_FILETYPE_SECURITY_CORE) {
+          *SecCoreImageBase = (PHYSICAL_ADDRESS) (UINTN) (Section + 1);
+        }
+        break;
+      }
+    }
+
+    //
+    // SEC Core image found
+    //
+    if (*SecCoreImageBase != 0) {
+      return EFI_SUCCESS;
+    }
+  }
+}
+
+/*
+  Find and return Pei Core entry point.
+
+  It also find SEC and PEI Core file debug inforamtion. It will report them if
+  remote debug is enabled.
+
+**/
+VOID
+EFIAPI
+FindAndReportEntryPoints (
+  IN  EFI_FIRMWARE_VOLUME_HEADER       **BootFirmwareVolumePtr,
+  OUT EFI_PEI_CORE_ENTRY_POINT         *PeiCoreEntryPoint
+  )
+{
+  EFI_STATUS                       Status;
+  EFI_PHYSICAL_ADDRESS             SecCoreImageBase;
+  EFI_PHYSICAL_ADDRESS             PeiCoreImageBase;
+  PE_COFF_LOADER_IMAGE_CONTEXT     ImageContext;
+
+  //
+  // Find SEC Core and PEI Core image base
+   //
+  Status = FindImageBase (*BootFirmwareVolumePtr, &SecCoreImageBase);
+  ASSERT_EFI_ERROR (Status);
+
+  FindPeiCoreImageBase (BootFirmwareVolumePtr, &PeiCoreImageBase);
+  
+  ZeroMem ((VOID *) &ImageContext, sizeof (PE_COFF_LOADER_IMAGE_CONTEXT));
+  //
+  // Report SEC Core debug information when remote debug is enabled
+  //
+  ImageContext.ImageAddress = SecCoreImageBase;
+  ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer ((VOID*) (UINTN) ImageContext.ImageAddress);
+  PeCoffLoaderRelocateImageExtraAction (&ImageContext);
+
+  //
+  // Report PEI Core debug information when remote debug is enabled
+  //
+  ImageContext.ImageAddress = (EFI_PHYSICAL_ADDRESS)(UINTN)PeiCoreImageBase;
+  ImageContext.PdbPointer = PeCoffLoaderGetPdbPointer ((VOID*) (UINTN) ImageContext.ImageAddress);
+  PeCoffLoaderRelocateImageExtraAction (&ImageContext);
+
+  //
+  // Find PEI Core entry point
+  //
+  Status = PeCoffLoaderGetEntryPoint ((VOID *) (UINTN) PeiCoreImageBase, (VOID**) PeiCoreEntryPoint);
+  if (EFI_ERROR (Status)) {
+    *PeiCoreEntryPoint = 0;
+  }
+
+  return;
+}
+
+VOID
+EFIAPI
+SecCoreStartupWithStack (
+  IN EFI_FIRMWARE_VOLUME_HEADER       *BootFv,
+  IN VOID                             *TopOfCurrentStack
+  )
+{
+  EFI_SEC_PEI_HAND_OFF        SecCoreData;
+  SEC_IDT_TABLE               IdtTableInStack;
+  IA32_DESCRIPTOR             IdtDescriptor;
+  UINT32                      Index;
+
+  ProcessLibraryConstructorList (NULL, NULL);
+
+  DEBUG ((EFI_D_ERROR,
+    "SecCoreStartupWithStack(0x%x, 0x%x)\n",
+    (UINT32)(UINTN)BootFv,
+    (UINT32)(UINTN)TopOfCurrentStack
+    ));
+
+  //
+  // Initialize floating point operating environment
+  // to be compliant with UEFI spec.
+  //
+  InitializeFloatingPointUnits ();
+
+  //
+  // Initialize IDT
+  //  
+  IdtTableInStack.PeiService = NULL;
+  for (Index = 0; Index < SEC_IDT_ENTRY_COUNT; Index ++) {
+    CopyMem (&IdtTableInStack.IdtTable[Index], &mIdtEntryTemplate, sizeof (mIdtEntryTemplate));
+  }
+
+  IdtDescriptor.Base  = (UINTN)&IdtTableInStack.IdtTable;
+  IdtDescriptor.Limit = (UINT16)(sizeof (IdtTableInStack.IdtTable) - 1);
+
+  AsmWriteIdtr (&IdtDescriptor);
+
+  //
+  // |-------------|       <-- TopOfCurrentStack
+  // |   Stack     | 32k
+  // |-------------|
+  // |    Heap     | 32k
+  // |-------------|       <-- SecCoreData.TemporaryRamBase
+  //
+
+  //
+  // Initialize SEC hand-off state
+  //
+  SecCoreData.DataSize = sizeof(EFI_SEC_PEI_HAND_OFF);
+
+  SecCoreData.TemporaryRamSize       = SIZE_64KB;
+  SecCoreData.TemporaryRamBase       = (VOID*)((UINT8 *)TopOfCurrentStack - SecCoreData.TemporaryRamSize);
+
+  SecCoreData.PeiTemporaryRamBase    = SecCoreData.TemporaryRamBase;
+  SecCoreData.PeiTemporaryRamSize    = SecCoreData.TemporaryRamSize >> 1;
+
+  SecCoreData.StackBase              = (UINT8 *)SecCoreData.TemporaryRamBase + SecCoreData.PeiTemporaryRamSize;
+  SecCoreData.StackSize              = SecCoreData.TemporaryRamSize >> 1;
+
+  SecCoreData.BootFirmwareVolumeBase = BootFv;
+  SecCoreData.BootFirmwareVolumeSize = (UINTN) BootFv->FvLength;
+
+  //
+  // Make sure the 8259 is masked before initializing the Debug Agent and the debug timer is enabled
+  //
+  IoWrite8 (0x21, 0xff);
+  IoWrite8 (0xA1, 0xff);
+  
+  //
+  // Initialize Debug Agent to support source level debug in SEC/PEI phases before memory ready.
+  //
+  InitializeDebugAgent (DEBUG_AGENT_INIT_PREMEM_SEC, &SecCoreData, SecStartupPhase2);
+}
+  
+/**
+  Caller provided function to be invoked at the end of InitializeDebugAgent().
+
+  Entry point to the C language phase of SEC. After the SEC assembly
+  code has initialized some temporary memory and set up the stack,
+  the control is transferred to this function.
+
+  @param[in] Context    The first input parameter of InitializeDebugAgent().
+
+**/
+VOID
+EFIAPI
+SecStartupPhase2(
+  IN VOID                     *Context
+  )
+{
+  EFI_SEC_PEI_HAND_OFF        *SecCoreData;
+  EFI_FIRMWARE_VOLUME_HEADER  *BootFv;
+  EFI_PEI_CORE_ENTRY_POINT    PeiCoreEntryPoint;
+  
+  SecCoreData = (EFI_SEC_PEI_HAND_OFF *) Context;
+  
+  //
+  // Find PEI Core entry point. It will report SEC and Pei Core debug information if remote debug
+  // is enabled.
+  //
+  BootFv = (EFI_FIRMWARE_VOLUME_HEADER *)SecCoreData->BootFirmwareVolumeBase;
+  FindAndReportEntryPoints (&BootFv, &PeiCoreEntryPoint);
+  SecCoreData->BootFirmwareVolumeBase = BootFv;
+  SecCoreData->BootFirmwareVolumeSize = (UINTN) BootFv->FvLength;
+
+  //
+  // Transfer the control to the PEI core
+  //
+  (*PeiCoreEntryPoint) (SecCoreData, (EFI_PEI_PPI_DESCRIPTOR *)&mPrivateDispatchTable);
+  
+  //
+  // If we get here then the PEI Core returned, which is not recoverable.
+  //
+  ASSERT (FALSE);
+  CpuDeadLoop ();
+}
+
+EFI_STATUS
+EFIAPI
+TemporaryRamMigration (
+  IN CONST EFI_PEI_SERVICES   **PeiServices,
+  IN EFI_PHYSICAL_ADDRESS     TemporaryMemoryBase,
+  IN EFI_PHYSICAL_ADDRESS     PermanentMemoryBase,
+  IN UINTN                    CopySize
+  )
+{
+  IA32_DESCRIPTOR                  IdtDescriptor;
+  VOID                             *OldHeap;
+  VOID                             *NewHeap;
+  VOID                             *OldStack;
+  VOID                             *NewStack;
+  DEBUG_AGENT_CONTEXT_POSTMEM_SEC  DebugAgentContext;
+  BOOLEAN                          OldStatus;
+  BASE_LIBRARY_JUMP_BUFFER         JumpBuffer;
+  
+  DEBUG ((EFI_D_ERROR, "TemporaryRamMigration(0x%x, 0x%x, 0x%x)\n", (UINTN)TemporaryMemoryBase, (UINTN)PermanentMemoryBase, CopySize));
+  
+  OldHeap = (VOID*)(UINTN)TemporaryMemoryBase;
+  NewHeap = (VOID*)((UINTN)PermanentMemoryBase + (CopySize >> 1));
+  
+  OldStack = (VOID*)((UINTN)TemporaryMemoryBase + (CopySize >> 1));
+  NewStack = (VOID*)(UINTN)PermanentMemoryBase;
+
+  DebugAgentContext.HeapMigrateOffset = (UINTN)NewHeap - (UINTN)OldHeap;
+  DebugAgentContext.StackMigrateOffset = (UINTN)NewStack - (UINTN)OldStack;
+  
+  OldStatus = SaveAndSetDebugTimerInterrupt (FALSE);
+  InitializeDebugAgent (DEBUG_AGENT_INIT_POSTMEM_SEC, (VOID *) &DebugAgentContext, NULL);
+
+  //
+  // Migrate Heap
+  //
+  CopyMem (NewHeap, OldHeap, CopySize >> 1);
+
+  //
+  // Migrate Stack
+  //
+  CopyMem (NewStack, OldStack, CopySize >> 1);
+  
+  //
+  // Rebase IDT table in permanent memory
+  //
+  AsmReadIdtr (&IdtDescriptor);
+  IdtDescriptor.Base = IdtDescriptor.Base - (UINTN)OldStack + (UINTN)NewStack;
+
+  AsmWriteIdtr (&IdtDescriptor);
+
+  //
+  // Use SetJump()/LongJump() to switch to a new stack.
+  // 
+  if (SetJump (&JumpBuffer) == 0) {
+#if defined (MDE_CPU_IA32)
+    JumpBuffer.Esp = JumpBuffer.Esp + DebugAgentContext.StackMigrateOffset;
+#endif    
+#if defined (MDE_CPU_X64)
+    JumpBuffer.Rsp = JumpBuffer.Rsp + DebugAgentContext.StackMigrateOffset;
+#endif    
+    LongJump (&JumpBuffer, (UINTN)-1);
+  }
+
+  SaveAndSetDebugTimerInterrupt (OldStatus);
+
+  return EFI_SUCCESS;
+}
+
diff --git a/corebootPkg/Sec/SecMain.inf b/corebootPkg/Sec/SecMain.inf
new file mode 100644
index 0000000..6b49434
--- /dev/null
+++ b/corebootPkg/Sec/SecMain.inf
@@ -0,0 +1,64 @@
+## @file
+#  SEC Driver
+#
+#  Copyright (c) 2008 - 2010, Intel Corporation. All rights reserved.<BR>
+#                2013 Patrick Georgi
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = SecMain
+  FILE_GUID                      = df1ccef6-f301-4a63-9661-fc6030dcc880
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = SecMain
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  SecMain.c
+
+[Sources.IA32]
+  Ia32/SecEntry.S   | GCC
+
+[Sources.X64]
+  X64/SecEntry.S    | GCC
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  UefiCpuPkg/UefiCpuPkg.dec
+  corebootPkg/corebootPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  DebugLib
+  BaseMemoryLib
+  PeiServicesLib
+  PcdLib
+  UefiCpuLib
+  DebugAgentLib
+  IoLib
+  PeCoffLib
+  PeCoffGetEntryPointLib
+  PeCoffExtraActionLib
+
+[Ppis]
+  gEfiTemporaryRamSupportPpiGuid                # PPI ALWAYS_PRODUCED
+
+[Pcd]
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvBase
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvSize
diff --git a/corebootPkg/Sec/X64/SecEntry.S b/corebootPkg/Sec/X64/SecEntry.S
new file mode 100644
index 0000000..3ad7d00
--- /dev/null
+++ b/corebootPkg/Sec/X64/SecEntry.S
@@ -0,0 +1,130 @@
+#      TITLE   SecEntry.asm
+#------------------------------------------------------------------------------
+#*
+#*   Copyright (c) 2006 - 2009, Intel Corporation. All rights reserved.<BR>
+#*                 2013 Patrick Georgi
+#*   This program and the accompanying materials
+#*   are licensed and made available under the terms and conditions of the BSD License
+#*   which accompanies this distribution.  The full text of the license may be found at
+#*   http://opensource.org/licenses/bsd-license.php
+#*
+#*   THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#*   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#*
+#*    CpuAsm.asm
+#*
+#*   Abstract:
+#*
+#------------------------------------------------------------------------------
+
+
+#include <Base.h>
+#include <Library/PcdLib.h>
+
+#EXTERN ASM_PFX(SecCoreStartupWithStack)
+
+#
+# SecCore Entry Point
+#
+# Processor is in flat protected mode
+#
+# @return     None  This routine does not return
+#
+
+#define FV_OFFSET 0x64
+
+.data
+.align 0x1000
+pml4: # bits 47:39
+    .quad pdpt + 3
+.align 0x1000
+pdpt: # bits 38:29
+    .quad pdt + 3
+.align 0x1000
+pdt: # bits 29:21
+.space 0x1000, 0
+
+gdt64:
+    .long 0
+    .long 0
+gdt64_code:
+    .word 0
+    .word 0
+    .byte 0
+    .byte 0x98
+    .byte 0x20
+    .byte 0
+gdt64_data:
+    .word 0
+    .word 0
+    .byte 0
+    .byte 0x90
+    .byte 0
+    .byte 0
+.align 4
+    .word 0
+gdt64_pointer:
+    .word 23 # length
+    .quad gdt64
+
+.text
+ASM_GLOBAL ASM_PFX(_ModuleEntryPoint)
+ASM_PFX(_ModuleEntryPoint):
+
+.code32
+    movl    $0x200, %ecx
+    movl    $pdt, %edi
+    movl    $0x83, %eax # 2MB page, R/W, P
+1:
+    movl    %eax, (%edi)
+    addl    $0x200000, %eax
+    addl    $0x8, %edi
+    loop    1b
+
+    # load new GDT
+    lgdtl   gdt64_pointer
+
+    # configure page tables
+    movl    $pml4, %eax
+    movl    %eax, %cr3
+
+    # enable PAE and PSE
+    movl    %cr4, %eax
+    bts     $5, %eax
+    movl    %eax, %cr4
+
+    # LM enable
+    movl    $0xc0000080, %ecx
+    rdmsr
+    orl     $0x100, %eax
+    wrmsr
+
+    # enable paging
+    movl    %cr0, %eax
+    bts     $31, %eax
+    movl    %eax, %cr0
+
+    ljmpl   $8, $realEntry
+
+.code64
+realEntry:
+
+    #
+    # Load temporary stack top at very low memory.  The C code
+    # can reload to a better address.
+    # Also load the base address of SECFV.
+    #
+    movq    $BASE_512KB, %rsp 
+    movq    $FixedPcdGet32(PcdCorebootMemFvBase), %rbp
+    nop
+
+    #
+    # Setup parameters and call SecCoreStartupWithStack
+    #   rcx: BootFirmwareVolumePtr
+    #   rdx: TopOfCurrentStack
+    #
+    movq    %rbp, %rcx
+    movq    %rsp, %rdx
+    subq    $0x20, %rsp
+    call    ASM_PFX(SecCoreStartupWithStack)
+
diff --git a/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
new file mode 100644
index 0000000..a52cda5
--- /dev/null
+++ b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
@@ -0,0 +1,172 @@
+/** @file
+  This driver installs SMBIOS information for OVMF
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "SmbiosPlatformDxe.h"
+
+
+/**
+  Validates the SMBIOS entry point structure
+
+  @param  EntryPointStructure  SMBIOS entry point structure
+
+  @retval TRUE   The entry point structure is valid
+  @retval FALSE  The entry point structure is not valid
+
+**/
+BOOLEAN
+IsEntryPointStructureValid (
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  )
+{
+  UINTN                     Index;
+  UINT8                     Length;
+  UINT8                     Checksum;
+  UINT8                     *BytePtr;
+
+  BytePtr = (UINT8*) EntryPointStructure;
+  Length = EntryPointStructure->EntryPointLength;
+  Checksum = 0;
+
+  for (Index = 0; Index < Length; Index++) {
+    Checksum = Checksum + (UINT8) BytePtr[Index];
+  }
+
+  if (Checksum != 0) {
+    return FALSE;
+  } else {
+    return TRUE;
+  }
+}
+
+
+/**
+  Get SMBIOS record length.
+
+  @param  SmbiosTable   SMBIOS pointer.
+
+**/
+UINTN
+SmbiosTableLength (
+  IN SMBIOS_STRUCTURE_POINTER SmbiosTable
+  )
+{
+  CHAR8  *AChar;
+  UINTN  Length;
+
+  AChar = (CHAR8 *)(SmbiosTable.Raw + SmbiosTable.Hdr->Length);
+
+  //
+  // Each structure shall be terminated by a double-null (SMBIOS spec.7.1)
+  //
+  while ((*AChar != 0) || (*(AChar + 1) != 0)) {
+    AChar ++;
+  }
+  Length = ((UINTN)AChar - (UINTN)SmbiosTable.Raw + 2);
+
+  return Length;
+}
+
+
+/**
+  Install all structures from the given SMBIOS structures block
+
+  @param  Smbios               SMBIOS protocol
+  @param  EntryPointStructure  SMBIOS entry point structures block
+
+**/
+EFI_STATUS
+InstallAllStructures (
+  IN EFI_SMBIOS_PROTOCOL       *Smbios,
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  )
+{
+  EFI_STATUS                Status;
+  SMBIOS_STRUCTURE_POINTER  SmbiosTable;
+  EFI_SMBIOS_HANDLE         SmbiosHandle;
+
+  SmbiosTable.Raw = (UINT8*)(UINTN) EntryPointStructure->TableAddress;
+  if (SmbiosTable.Raw == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  while (SmbiosTable.Hdr->Type != 127) {
+    //
+    // Log the SMBIOS data for this structure
+    //
+    SmbiosHandle = SMBIOS_HANDLE_PI_RESERVED;
+    Status = Smbios->Add (
+                       Smbios,
+                       NULL,
+                       &SmbiosHandle,
+                       (EFI_SMBIOS_TABLE_HEADER*) SmbiosTable.Raw
+                       );
+    ASSERT_EFI_ERROR (Status);
+
+    //
+    // Get the next structure address
+    //
+    SmbiosTable.Raw = (UINT8 *)(SmbiosTable.Raw + SmbiosTableLength (SmbiosTable));
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Installs SMBIOS information for OVMF
+
+  @param ImageHandle     Module's image handle
+  @param SystemTable     Pointer of EFI_SYSTEM_TABLE
+
+  @retval EFI_SUCCESS    Smbios data successfully installed
+  @retval Other          Smbios data was not installed
+
+**/
+EFI_STATUS
+EFIAPI
+SmbiosTablePublishEntry (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  EFI_STATUS                Status;
+  EFI_SMBIOS_PROTOCOL       *Smbios;
+#if 0
+  SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure;
+#endif
+
+  //
+  // Find the SMBIOS protocol
+  //
+  Status = gBS->LocateProtocol (
+                  &gEfiSmbiosProtocolGuid,
+                  NULL,
+                  (VOID**)&Smbios
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  // TODO: register coreboot SMBIOS tables with tianocore
+#if 0
+  EntryPointStructure = GetXenSmbiosTables (); <-- needs function that looks up system SMBIOS table
+  if (EntryPointStructure != NULL) {
+    Status = InstallAllStructures (Smbios, EntryPointStructure);
+  }
+#endif
+
+  return Status;
+}
diff --git a/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h
new file mode 100644
index 0000000..871d532
--- /dev/null
+++ b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h
@@ -0,0 +1,44 @@
+/** @file
+  This driver installs SMBIOS information for OVMF
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _SMBIOS_PLATFORM_DXE_H_
+#define _SMBIOS_PLATFORM_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Protocol/Smbios.h>
+#include <IndustryStandard/SmBios.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+
+
+/**
+  Validates the SMBIOS entry point structure
+
+  @param  EntryPointStructure  SMBIOS entry point structure
+
+  @retval TRUE   The entry point structure is valid
+  @retval FALSE  The entry point structure is not valid
+
+**/
+BOOLEAN
+IsEntryPointStructureValid (
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  );
+
+#endif
diff --git a/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
new file mode 100644
index 0000000..85ec925
--- /dev/null
+++ b/corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
@@ -0,0 +1,53 @@
+## @file
+#  This driver installs SMBIOS information for OVMF
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = SmbiosPlatformDxe
+  FILE_GUID                      = 4110465d-5ff3-4f4b-b580-24ed0d06747a
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+
+  ENTRY_POINT                    = SmbiosTablePublishEntry
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  SmbiosPlatformDxe.h
+  SmbiosPlatformDxe.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  corebootPkg/corebootPkg.dec
+
+[LibraryClasses]
+  UefiBootServicesTableLib
+  BaseMemoryLib
+  BaseLib
+  UefiDriverEntryPoint
+  DebugLib
+  HobLib
+
+[Protocols]
+  gEfiSmbiosProtocolGuid                      # PROTOCOL ALWAYS_CONSUMED
+
+[Depex]
+  gEfiSmbiosProtocolGuid
+
diff --git a/corebootPkg/corebootPkg.dec b/corebootPkg/corebootPkg.dec
new file mode 100644
index 0000000..c218652
--- /dev/null
+++ b/corebootPkg/corebootPkg.dec
@@ -0,0 +1,35 @@
+## @file
+#  EFI/Framework Open Virtual Machine Firmware (OVMF) platform
+#
+#  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  DEC_SPECIFICATION              = 0x00010005
+  PACKAGE_NAME                   = corebootPkg
+  PACKAGE_GUID                   = 007fd4d1-911f-4c48-86b2-1d3cb2ff4e45
+  PACKAGE_VERSION                = 0.1
+
+[Guids]
+  gUefiCorebootPkgTokenSpaceGuid      = {0x7511213d, 0x9403, 0x452c, {0xb2, 0x96, 0xcb, 0x15, 0xb6, 0xbb, 0xae, 0x6a}}
+
+[PcdsFixedAtBuild]
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvBase|0x0|UINT32|0
+  gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvSize|0x0|UINT32|1
+
+  ## This flag is used to control the destination port for PlatformDebugLibIoPort
+  gUefiCorebootPkgTokenSpaceGuid.PcdDebugIoPort|0x402|UINT16|4
+
+  ## This flag determines the Power Management Base Address of choice, written
+  #  to PIIX4 function 3 offset 0x40-0x43 bits [15:6].
+  gUefiCorebootPkgTokenSpaceGuid.PcdAcpiPmBaseAddress|0xB000|UINT16|5
+
diff --git a/corebootPkg/corebootPkg.dsc b/corebootPkg/corebootPkg.dsc
new file mode 100644
index 0000000..16d5a86
--- /dev/null
+++ b/corebootPkg/corebootPkg.dsc
@@ -0,0 +1,524 @@
+## @file
+#  EFI/Framework Open Virtual Machine Firmware (OVMF) platform
+#
+#  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  PLATFORM_NAME                  = coreboot
+  PLATFORM_GUID                  = 5c87b2d4-0bb9-4f50-a78d-e847089af9f4
+  PLATFORM_VERSION               = 0.1
+  DSC_SPECIFICATION              = 0x00010005
+  OUTPUT_DIRECTORY               = Build/coreboot$(ARCH)
+  SUPPORTED_ARCHITECTURES        = IA32|X64
+  BUILD_TARGETS                  = DEBUG|RELEASE
+  SKUID_IDENTIFIER               = DEFAULT
+  FLASH_DEFINITION               = corebootPkg/corebootPkg.fdf
+
+  #
+  # Defines for default states.  These can be changed on the command line.
+  # -D FLAG=VALUE
+  #
+  DEFINE SECURE_BOOT_ENABLE      = FALSE
+  DEFINE DEBUG_ON_SERIAL_PORT    = TRUE
+  DEFINE SOURCE_DEBUG_ENABLE     = FALSE
+  DEFINE CSM_ENABLE              = FALSE
+  DEFINE NETWORK_ENABLE          = FALSE
+  DEFINE BUILD_NEW_SHELL         = TRUE
+  DEFINE USE_NEW_SHELL           = FALSE
+
+[BuildOptions]
+  GCC:RELEASE_*_*_CC_FLAGS             = -DMDEPKG_NDEBUG
+  INTEL:RELEASE_*_*_CC_FLAGS           = /D MDEPKG_NDEBUG
+  MSFT:RELEASE_*_*_CC_FLAGS            = /D MDEPKG_NDEBUG
+  GCC:*_*_*_CC_FLAGS                   = -mno-mmx -mno-sse
+!if $(SOURCE_DEBUG_ENABLE)
+  MSFT:*_*_X64_GENFW_FLAGS  = --keepexceptiontable
+  GCC:*_*_X64_GENFW_FLAGS   = --keepexceptiontable
+  INTEL:*_*_X64_GENFW_FLAGS = --keepexceptiontable
+!endif
+
+################################################################################
+#
+# SKU Identification section - list of all SKU IDs supported by this Platform.
+#
+################################################################################
+[SkuIds]
+  0|DEFAULT
+
+################################################################################
+#
+# Library Class section - list of all Library Classes needed by this Platform.
+#
+################################################################################
+[LibraryClasses]
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  TimerLib|corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
+  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+  BaseMemoryLib|MdePkg/Library/BaseMemoryLibRepStr/BaseMemoryLibRepStr.inf
+  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
+  SynchronizationLib|MdePkg/Library/BaseSynchronizationLib/BaseSynchronizationLib.inf
+  CpuLib|MdePkg/Library/BaseCpuLib/BaseCpuLib.inf
+  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+  CacheMaintenanceLib|MdePkg/Library/BaseCacheMaintenanceLib/BaseCacheMaintenanceLib.inf
+  UefiDecompressLib|MdePkg/Library/BaseUefiDecompressLib/BaseUefiDecompressLib.inf
+  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf
+  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf
+  GenericBdsLib|IntelFrameworkModulePkg/Library/GenericBdsLib/GenericBdsLib.inf
+  CapsuleLib|MdeModulePkg/Library/DxeCapsuleLibNull/DxeCapsuleLibNull.inf
+  DxeServicesLib|MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
+  DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+  PciCf8Lib|MdePkg/Library/BasePciCf8Lib/BasePciCf8Lib.inf
+  PciLib|MdePkg/Library/BasePciLibCf8/BasePciLibCf8.inf
+  IoLib|MdePkg/Library/BaseIoLibIntrinsic/BaseIoLibIntrinsic.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  SerialPortLib|PcAtChipsetPkg/Library/SerialIoLib/SerialIoLib.inf
+  MtrrLib|UefiCpuPkg/Library/MtrrLib/MtrrLib.inf
+  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
+  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
+  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
+  UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
+  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
+  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
+  FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
+  UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
+  SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
+  NetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf
+  IpIoLib|MdeModulePkg/Library/DxeIpIoLib/DxeIpIoLib.inf
+  UdpIoLib|MdeModulePkg/Library/DxeUdpIoLib/DxeUdpIoLib.inf
+  DpcLib|MdeModulePkg/Library/DxeDpcLib/DxeDpcLib.inf
+  UefiUsbLib|MdePkg/Library/UefiUsbLib/UefiUsbLib.inf
+  LockBoxLib|MdeModulePkg/Library/LockBoxNullLib/LockBoxNullLib.inf
+
+!if $(SOURCE_DEBUG_ENABLE)
+  PeCoffExtraActionLib|SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLibDebug.inf
+  DebugCommunicationLib|SourceLevelDebugPkg/Library/DebugCommunicationLibSerialPort/DebugCommunicationLibSerialPort.inf
+!else
+  PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  DebugAgentLib|MdeModulePkg/Library/DebugAgentLibNull/DebugAgentLibNull.inf
+!endif
+
+  ResetSystemLib|corebootPkg/Library/ResetSystemLib/ResetSystemLib.inf
+  LocalApicLib|UefiCpuPkg/Library/BaseXApicLib/BaseXApicLib.inf
+  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
+  CpuExceptionHandlerLib|MdeModulePkg/Library/CpuExceptionHandlerLibNull/CpuExceptionHandlerLibNull.inf
+
+!if $(SECURE_BOOT_ENABLE)
+  PlatformSecureLib|corebootPkg/Library/PlatformSecureLib/PlatformSecureLib.inf
+  IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf
+  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf
+!endif
+
+[LibraryClasses.common]
+!if $(SECURE_BOOT_ENABLE)
+  BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf
+!endif
+
+[LibraryClasses.common.SEC]
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE)
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+
+[LibraryClasses.common.PEI_CORE]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeiCoreEntryPoint|MdePkg/Library/PeiCoreEntryPoint/PeiCoreEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+
+[LibraryClasses.common.PEIM]
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeimEntryPoint|MdePkg/Library/PeimEntryPoint/PeimEntryPoint.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+  PeiResourcePublicationLib|MdePkg/Library/PeiResourcePublicationLib/PeiResourcePublicationLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/PeiExtractGuidedSectionLib/PeiExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE)
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SecPeiDebugAgentLib.inf
+!endif
+
+[LibraryClasses.common.DXE_CORE]
+  HobLib|MdePkg/Library/DxeCoreHobLib/DxeCoreHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdeModulePkg/Library/DxeCoreMemoryAllocationLib/DxeCoreMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  ExtractGuidedSectionLib|MdePkg/Library/DxeExtractGuidedSectionLib/DxeExtractGuidedSectionLib.inf
+!if $(SOURCE_DEBUG_ENABLE)
+  DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+!endif
+
+[LibraryClasses.common.DXE_RUNTIME_DRIVER]
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/RuntimeDxeReportStatusCodeLib/RuntimeDxeReportStatusCodeLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  UefiRuntimeLib|MdePkg/Library/UefiRuntimeLib/UefiRuntimeLib.inf
+!if $(SECURE_BOOT_ENABLE)
+  BaseCryptLib|CryptoPkg/Library/BaseCryptLib/RuntimeCryptLib.inf
+!endif
+
+[LibraryClasses.common.UEFI_DRIVER]
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  DxeCoreEntryPoint|MdePkg/Library/DxeCoreEntryPoint/DxeCoreEntryPoint.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  UefiScsiLib|MdePkg/Library/UefiScsiLib/UefiScsiLib.inf
+
+[LibraryClasses.common.DXE_DRIVER]
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf
+  UefiScsiLib|MdePkg/Library/UefiScsiLib/UefiScsiLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+  NetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf
+  IpIoLib|MdeModulePkg/Library/DxeIpIoLib/DxeIpIoLib.inf
+  UdpIoLib|MdeModulePkg/Library/DxeUdpIoLib/DxeUdpIoLib.inf
+  DpcLib|MdeModulePkg/Library/DxeDpcLib/DxeDpcLib.inf
+  PlatformBdsLib|corebootPkg/Library/PlatformBdsLib/PlatformBdsLib.inf
+
+[LibraryClasses.common.UEFI_APPLICATION]
+  HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
+  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
+!if $(DEBUG_ON_SERIAL_PORT)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|corebootPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
+!endif
+
+################################################################################
+#
+# Pcd Section - list of all EDK II PCD Entries defined by this Platform.
+#
+################################################################################
+[PcdsFeatureFlag]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseSerial|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseMemory|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDxeIplSupportUefiDecompress|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDxeIplSwitchToLongMode|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutGopSupport|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutUgaSupport|FALSE
+
+[PcdsFixedAtBuild]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeMemorySize|1
+  gEfiMdeModulePkgTokenSpaceGuid.PcdResetOnMemoryTypeInformationChange|FALSE
+  gEfiMdePkgTokenSpaceGuid.PcdMaximumGuidedExtractHandler|0x10
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPeiCoreMaxFvSupported|6
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPeiCoreMaxPeimPerFv|32
+!if $(SECURE_BOOT_ENABLE)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x10000
+!else
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x400
+!endif
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxHardwareErrorVariableSize|0x8000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize|0xc000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize|0xc000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize|0x2000
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize|0x10000
+
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVpdBaseAddress|0x0
+
+  gEfiMdePkgTokenSpaceGuid.PcdReportStatusCodePropertyMask|0x07
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x8000004F
+!if $(SOURCE_DEBUG_ENABLE)
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x17
+!else
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x2F
+!endif
+
+!if $(SOURCE_DEBUG_ENABLE)
+  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x2
+!endif
+
+!if $(BUILD_NEW_SHELL)
+  gEfiIntelFrameworkModulePkgTokenSpaceGuid.PcdShellFile|{ 0x83, 0xA5, 0x04, 0x7C, 0x3E, 0x9E, 0x1C, 0x4F, 0xAD, 0x65, 0xE0, 0x52, 0x68, 0xD0, 0xB4, 0xD1 }
+!else
+!if $(USE_NEW_SHELL)
+  gEfiIntelFrameworkModulePkgTokenSpaceGuid.PcdShellFile|{ 0x83, 0xA5, 0x04, 0x7C, 0x3E, 0x9E, 0x1C, 0x4F, 0xAD, 0x65, 0xE0, 0x52, 0x68, 0xD0, 0xB4, 0xD1 }
+!endif
+!endif
+
+!if $(SECURE_BOOT_ENABLE)
+  # override the default values from SecurityPkg to ensure images from all sources are verified in secure boot
+  gEfiSecurityPkgTokenSpaceGuid.PcdOptionRomImageVerificationPolicy|0x05
+  gEfiSecurityPkgTokenSpaceGuid.PcdFixedMediaImageVerificationPolicy|0x05
+  gEfiSecurityPkgTokenSpaceGuid.PcdRemovableMediaImageVerificationPolicy|0x05
+!endif
+
+  # IRQs 5, 9, 10, 11 are level-triggered
+  gPcAtChipsetPkgTokenSpaceGuid.Pcd8259LegacyModeEdgeLevel|0x0E20
+
+################################################################################
+#
+# Pcd Dynamic Section - list of all EDK II PCD Entries defined by this Platform
+#
+################################################################################
+
+[PcdsDynamicDefault]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvStoreReserved|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase|0
+
+
+################################################################################
+#
+# Components Section - list of all EDK II Modules needed by this Platform.
+#
+################################################################################
+[Components]
+  #
+  # SEC Phase modules
+  #
+  corebootPkg/Sec/SecMain.inf
+
+  #
+  # PEI Phase modules
+  #
+  MdeModulePkg/Core/Pei/PeiMain.inf
+  MdeModulePkg/Universal/PCD/Pei/Pcd.inf  {
+    <LibraryClasses>
+      PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  }
+  IntelFrameworkModulePkg/Universal/StatusCode/Pei/StatusCodePei.inf
+  MdeModulePkg/Core/DxeIplPeim/DxeIpl.inf
+
+  corebootPkg/PlatformPei/PlatformPei.inf {
+    <LibraryClasses>
+      PcdLib|MdePkg/Library/PeiPcdLib/PeiPcdLib.inf
+  }
+
+  #
+  # DXE Phase modules
+  #
+  MdeModulePkg/Core/Dxe/DxeMain.inf {
+    <LibraryClasses>
+      NULL|IntelFrameworkModulePkg/Library/LzmaCustomDecompressLib/LzmaCustomDecompressLib.inf
+  }
+
+  IntelFrameworkModulePkg/Universal/StatusCode/RuntimeDxe/StatusCodeRuntimeDxe.inf
+  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf  {
+   <LibraryClasses>
+      PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  }
+
+  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+
+!if $(SECURE_BOOT_ENABLE)
+  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf {
+    <LibraryClasses>
+      NULL|SecurityPkg/Library/DxeImageVerificationLib/DxeImageVerificationLib.inf
+	}
+!else
+  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
+!endif
+
+  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
+  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
+  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
+  UefiCpuPkg/CpuDxe/CpuDxe.inf
+  PcAtChipsetPkg/8254TimerDxe/8254Timer.inf
+  PcAtChipsetPkg/PciHostBridgeDxe/PciHostBridgeDxe.inf
+  MdeModulePkg/Bus/Pci/PciBusDxe/PciBusDxe.inf
+  PcAtChipsetPkg/KbcResetDxe/Reset.inf
+  MdeModulePkg/Universal/Metronome/Metronome.inf {
+    <LibraryClasses>
+      TimerLib|corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
+  }
+
+  PcAtChipsetPkg/PcatRealTimeClockRuntimeDxe/PcatRealTimeClockRuntimeDxe.inf {
+    <LibraryClasses>
+      TimerLib|corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
+  }
+
+  IntelFrameworkModulePkg/Universal/BdsDxe/BdsDxe.inf {
+    <LibraryClasses>
+      TimerLib|corebootPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
+!if $(CSM_ENABLE)
+      NULL|corebootPkg/Csm/CsmSupportLib/CsmSupportLib.inf
+!endif
+  }
+
+  # FIXME: remove and replace with real flash driver
+  OvmfPkg/EmuVariableFvbRuntimeDxe/Fvb.inf {
+    <LibraryClasses>
+      PlatformFvbLib|OvmfPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.inf
+  }
+  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
+  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
+  MdeModulePkg/Universal/WatchdogTimerDxe/WatchdogTimer.inf
+  MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
+  MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
+  MdeModulePkg/Universal/Console/ConPlatformDxe/ConPlatformDxe.inf
+  MdeModulePkg/Universal/Console/ConSplitterDxe/ConSplitterDxe.inf
+  MdeModulePkg/Universal/Console/GraphicsConsoleDxe/GraphicsConsoleDxe.inf
+  MdeModulePkg/Universal/Console/TerminalDxe/TerminalDxe.inf
+  MdeModulePkg/Universal/DevicePathDxe/DevicePathDxe.inf
+  MdeModulePkg/Universal/PrintDxe/PrintDxe.inf
+  MdeModulePkg/Universal/Disk/DiskIoDxe/DiskIoDxe.inf
+  MdeModulePkg/Universal/Disk/PartitionDxe/PartitionDxe.inf
+  MdeModulePkg/Universal/Disk/UnicodeCollation/EnglishDxe/EnglishDxe.inf
+  MdeModulePkg/Bus/Scsi/ScsiBusDxe/ScsiBusDxe.inf
+  MdeModulePkg/Bus/Scsi/ScsiDiskDxe/ScsiDiskDxe.inf
+  IntelFrameworkModulePkg/Bus/Pci/IdeBusDxe/IdeBusDxe.inf
+  PcAtChipsetPkg/Bus/Pci/IdeControllerDxe/IdeControllerDxe.inf
+  MdeModulePkg/Universal/HiiDatabaseDxe/HiiDatabaseDxe.inf
+  MdeModulePkg/Universal/SetupBrowserDxe/SetupBrowserDxe.inf
+  MdeModulePkg/Universal/MemoryTest/NullMemoryTestDxe/NullMemoryTestDxe.inf
+
+  #
+  # ISA Support
+  #
+  PcAtChipsetPkg/IsaAcpiDxe/IsaAcpi.inf
+  IntelFrameworkModulePkg/Bus/Isa/IsaBusDxe/IsaBusDxe.inf
+  IntelFrameworkModulePkg/Bus/Isa/IsaSerialDxe/IsaSerialDxe.inf
+  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
+  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
+
+  #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  corebootPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
+  # ACPI Support
+  #
+  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
+
+  #
+  # Network Support
+  #
+!if $(NETWORK_ENABLE)
+  MdeModulePkg/Universal/Network/SnpDxe/SnpDxe.inf
+  MdeModulePkg/Universal/Network/DpcDxe/DpcDxe.inf
+  MdeModulePkg/Universal/Network/MnpDxe/MnpDxe.inf
+  MdeModulePkg/Universal/Network/VlanConfigDxe/VlanConfigDxe.inf
+  MdeModulePkg/Universal/Network/ArpDxe/ArpDxe.inf
+  MdeModulePkg/Universal/Network/Dhcp4Dxe/Dhcp4Dxe.inf
+  MdeModulePkg/Universal/Network/Ip4ConfigDxe/Ip4ConfigDxe.inf
+  MdeModulePkg/Universal/Network/Ip4Dxe/Ip4Dxe.inf
+  MdeModulePkg/Universal/Network/Mtftp4Dxe/Mtftp4Dxe.inf
+  MdeModulePkg/Universal/Network/Tcp4Dxe/Tcp4Dxe.inf
+  MdeModulePkg/Universal/Network/Udp4Dxe/Udp4Dxe.inf
+  MdeModulePkg/Universal/Network/UefiPxeBcDxe/UefiPxeBcDxe.inf
+  MdeModulePkg/Universal/Network/IScsiDxe/IScsiDxe.inf
+!endif
+
+  #
+  # Usb Support
+  #
+  MdeModulePkg/Bus/Pci/UhciDxe/UhciDxe.inf
+  MdeModulePkg/Bus/Pci/EhciDxe/EhciDxe.inf
+  MdeModulePkg/Bus/Usb/UsbBusDxe/UsbBusDxe.inf
+  MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf
+  MdeModulePkg/Bus/Usb/UsbMassStorageDxe/UsbMassStorageDxe.inf
+
+!if $(CSM_ENABLE)
+  IntelFrameworkModulePkg/Csm/BiosThunk/VideoDxe/VideoDxe.inf
+  IntelFrameworkModulePkg/Csm/LegacyBiosDxe/LegacyBiosDxe.inf
+  corebootPkg/Csm/Csm16/Csm16.inf
+!endif
+
+!if $(BUILD_NEW_SHELL)
+  ShellPkg/Application/Shell/Shell.inf {
+    <LibraryClasses>
+      ShellCommandLib|ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf
+      HandleParsingLib|ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf
+      FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
+      ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf
+      SortLib|ShellPkg/Library/UefiSortLib/UefiSortLib.inf
+      PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+      PathLib|ShellPkg/Library/BasePathLib/BasePathLib.inf
+#      SafeBlockIoLib|ShellPkg/Library/SafeBlockIoLib/SafeBlockIoLib.inf
+#      SafeOpenProtocolLib|ShellPkg/Library/SafeOpenProtocolLib/SafeOpenProtocolLib.inf
+
+    <PcdsFixedAtBuild>
+      gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0xFF
+      gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE
+      gEfiMdePkgTokenSpaceGuid.PcdUefiLibMaxPrintBufferSize|8000
+  }
+!endif
+
+!if $(SECURE_BOOT_ENABLE)
+  SecurityPkg/VariableAuthenticated/RuntimeDxe/VariableRuntimeDxe.inf {
+    <LibraryClasses>
+      BaseCryptLib|CryptoPkg/Library/BaseCryptLib/RuntimeCryptLib.inf
+      OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf
+  }
+!endif
diff --git a/corebootPkg/corebootPkg.fdf b/corebootPkg/corebootPkg.fdf
new file mode 100644
index 0000000..379f681
--- /dev/null
+++ b/corebootPkg/corebootPkg.fdf
@@ -0,0 +1,328 @@
+## @file
+#  Open Virtual Machine Firmware: FDF
+#
+#  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+################################################################################
+[FD.coreboot]
+BaseAddress   = 0x800000|gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvBase
+Size          = 0x600000|gUefiCorebootPkgTokenSpaceGuid.PcdCorebootMemFvSize
+ErasePolarity = 1
+BlockSize     = 0x1000
+NumBlocks     = 0x600
+
+0x00000000|0x014000
+FV = SECFV
+
+0x00014000|0x5ec000
+FV = MAINFV
+
+################################################################################
+
+[FV.SECFV]
+BlockSize          = 0x1000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+#
+# SEC Phase modules
+#
+# The code in this FV handles the initial startup, and locates MAINFV
+# which handles the majority of the boot sequence.
+#
+INF  corebootPkg/Sec/SecMain.inf
+
+################################################################################
+[FV.MAINFV]
+BlockSize          = 0x10000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+#
+# Files to be placed in MAIN FV
+#
+# This firmware volume will have files placed in it uncompressed,
+# and then then entire firmware volume will be compressed in a
+# single compression operation in order to achieve better
+# overall compression.
+#
+
+APRIORI PEI {
+  INF  MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+}
+
+#
+#  PEI Phase modules
+#
+INF  MdeModulePkg/Core/Pei/PeiMain.inf
+INF  MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+INF  IntelFrameworkModulePkg/Universal/StatusCode/Pei/StatusCodePei.inf
+INF  corebootPkg/PlatformPei/PlatformPei.inf
+INF  MdeModulePkg/Core/DxeIplPeim/DxeIpl.inf
+
+FILE FV_IMAGE = A4EF5A93-3F1B-4232-A1C4-F0910E6D1D9C {
+  SECTION COMPRESS PI_NONE {
+    SECTION FV_IMAGE = DXEFV
+  }
+}
+
+################################################################################
+
+[FV.DXEFV]
+BlockSize          = 0x10000
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+
+APRIORI DXE {
+  INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
+}
+
+#
+# DXE Phase modules
+#
+INF  MdeModulePkg/Core/Dxe/DxeMain.inf
+
+INF  IntelFrameworkModulePkg/Universal/StatusCode/RuntimeDxe/StatusCodeRuntimeDxe.inf
+INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
+
+INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
+INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
+INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
+INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
+INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
+INF  PcAtChipsetPkg/8254TimerDxe/8254Timer.inf
+INF  PcAtChipsetPkg/PciHostBridgeDxe/PciHostBridgeDxe.inf
+INF  MdeModulePkg/Bus/Pci/PciBusDxe/PciBusDxe.inf
+INF  PcAtChipsetPkg/KbcResetDxe/Reset.inf
+INF  MdeModulePkg/Universal/Metronome/Metronome.inf
+INF  PcAtChipsetPkg/PcatRealTimeClockRuntimeDxe/PcatRealTimeClockRuntimeDxe.inf
+
+INF  OvmfPkg/EmuVariableFvbRuntimeDxe/Fvb.inf
+INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
+
+!if $(SECURE_BOOT_ENABLE)
+  INF  SecurityPkg/VariableAuthenticated/RuntimeDxe/VariableRuntimeDxe.inf
+!else
+  INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
+!endif
+
+INF  MdeModulePkg/Universal/WatchdogTimerDxe/WatchdogTimer.inf
+INF  MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
+INF  MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
+INF  MdeModulePkg/Universal/Console/ConPlatformDxe/ConPlatformDxe.inf
+INF  MdeModulePkg/Universal/Console/ConSplitterDxe/ConSplitterDxe.inf
+INF  MdeModulePkg/Universal/Console/GraphicsConsoleDxe/GraphicsConsoleDxe.inf
+INF  MdeModulePkg/Universal/Console/TerminalDxe/TerminalDxe.inf
+INF  IntelFrameworkModulePkg/Universal/BdsDxe/BdsDxe.inf
+INF  MdeModulePkg/Universal/DevicePathDxe/DevicePathDxe.inf
+INF  MdeModulePkg/Universal/PrintDxe/PrintDxe.inf
+INF  MdeModulePkg/Universal/Disk/DiskIoDxe/DiskIoDxe.inf
+INF  MdeModulePkg/Universal/Disk/PartitionDxe/PartitionDxe.inf
+INF  MdeModulePkg/Universal/Disk/UnicodeCollation/EnglishDxe/EnglishDxe.inf
+INF  MdeModulePkg/Bus/Scsi/ScsiBusDxe/ScsiBusDxe.inf
+INF  MdeModulePkg/Bus/Scsi/ScsiDiskDxe/ScsiDiskDxe.inf
+INF  IntelFrameworkModulePkg/Bus/Pci/IdeBusDxe/IdeBusDxe.inf
+INF  PcAtChipsetPkg/Bus/Pci/IdeControllerDxe/IdeControllerDxe.inf
+INF  MdeModulePkg/Universal/HiiDatabaseDxe/HiiDatabaseDxe.inf
+INF  MdeModulePkg/Universal/SetupBrowserDxe/SetupBrowserDxe.inf
+INF  MdeModulePkg/Universal/MemoryTest/NullMemoryTestDxe/NullMemoryTestDxe.inf
+
+INF  PcAtChipsetPkg/IsaAcpiDxe/IsaAcpi.inf
+INF  IntelFrameworkModulePkg/Bus/Isa/IsaBusDxe/IsaBusDxe.inf
+
+!if !$(SOURCE_DEBUG_ENABLE)
+INF  IntelFrameworkModulePkg/Bus/Isa/IsaSerialDxe/IsaSerialDxe.inf
+!endif
+
+INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
+INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
+
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+
+INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
+
+INF  RuleOverride = BINARY FatBinPkg/EnhancedFatDxe/Fat.inf
+
+!if $(BUILD_NEW_SHELL)
+INF  ShellPkg/Application/Shell/Shell.inf
+!else
+!if $(USE_NEW_SHELL)
+INF  RuleOverride = BINARY ShellBinPkg/UefiShell/UefiShell.inf
+!else
+INF  RuleOverride = BINARY EdkShellBinPkg/FullShell/FullShell.inf
+!endif
+!endif
+
+FILE FREEFORM = PCD(gEfiIntelFrameworkModulePkgTokenSpaceGuid.PcdLogoFile) {
+  SECTION RAW = MdeModulePkg/Logo/Logo.bmp
+}
+
+#
+# Network modules
+#
+!if $(NETWORK_ENABLE)
+  INF  MdeModulePkg/Universal/Network/SnpDxe/SnpDxe.inf
+  INF  MdeModulePkg/Universal/Network/DpcDxe/DpcDxe.inf
+  INF  MdeModulePkg/Universal/Network/MnpDxe/MnpDxe.inf
+  INF  MdeModulePkg/Universal/Network/VlanConfigDxe/VlanConfigDxe.inf
+  INF  MdeModulePkg/Universal/Network/ArpDxe/ArpDxe.inf
+  INF  MdeModulePkg/Universal/Network/Dhcp4Dxe/Dhcp4Dxe.inf
+  INF  MdeModulePkg/Universal/Network/Ip4ConfigDxe/Ip4ConfigDxe.inf
+  INF  MdeModulePkg/Universal/Network/Ip4Dxe/Ip4Dxe.inf
+  INF  MdeModulePkg/Universal/Network/Mtftp4Dxe/Mtftp4Dxe.inf
+  INF  MdeModulePkg/Universal/Network/Tcp4Dxe/Tcp4Dxe.inf
+  INF  MdeModulePkg/Universal/Network/Udp4Dxe/Udp4Dxe.inf
+  INF  MdeModulePkg/Universal/Network/UefiPxeBcDxe/UefiPxeBcDxe.inf
+  INF  MdeModulePkg/Universal/Network/IScsiDxe/IScsiDxe.inf
+!endif
+
+#
+# Usb Support
+#
+INF  MdeModulePkg/Bus/Pci/UhciDxe/UhciDxe.inf
+INF  MdeModulePkg/Bus/Pci/EhciDxe/EhciDxe.inf
+INF  MdeModulePkg/Bus/Usb/UsbBusDxe/UsbBusDxe.inf
+INF  MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf
+INF  MdeModulePkg/Bus/Usb/UsbMassStorageDxe/UsbMassStorageDxe.inf
+
+!if $(CSM_ENABLE)
+INF  IntelFrameworkModulePkg/Csm/BiosThunk/VideoDxe/VideoDxe.inf
+INF  IntelFrameworkModulePkg/Csm/LegacyBiosDxe/LegacyBiosDxe.inf
+INF  RuleOverride=CSM corebootPkg/Csm/Csm16/Csm16.inf
+!endif
+
+################################################################################
+
+[Rule.Common.SEC]
+  FILE SEC = $(NAMED_GUID) {
+    PE32     PE32   Align=4K   $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING ="$(MODULE_NAME)" Optional
+    VERSION  STRING ="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEI_CORE]
+  FILE PEI_CORE = $(NAMED_GUID) {
+    PE32     PE32   Align=32    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING ="$(MODULE_NAME)" Optional
+    VERSION  STRING ="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEIM]
+  FILE PEIM = $(NAMED_GUID) {
+     PEI_DEPEX PEI_DEPEX Optional        $(INF_OUTPUT)/$(MODULE_NAME).depex
+     PE32      PE32   Align=32           $(INF_OUTPUT)/$(MODULE_NAME).efi
+     UI       STRING="$(MODULE_NAME)" Optional
+     VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_CORE]
+  FILE DXE_CORE = $(NAMED_GUID) {
+    PE32     PE32           $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.DXE_RUNTIME_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_DRIVER]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX    DXE_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_DRIVER.BINARY]
+  FILE DRIVER = $(NAMED_GUID) {
+    DXE_DEPEX DXE_DEPEX Optional      |.depex
+    PE32      PE32                    |.efi
+    UI        STRING="$(MODULE_NAME)" Optional
+    VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_APPLICATION]
+  FILE APPLICATION = $(NAMED_GUID) {
+    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.UEFI_APPLICATION.BINARY]
+  FILE APPLICATION = $(NAMED_GUID) {
+    PE32      PE32                    |.efi
+    UI        STRING="$(MODULE_NAME)" Optional
+    VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.USER_DEFINED.CSM]
+  FILE FREEFORM = $(NAMED_GUID) {
+    RAW BIN                |.bin
+  }
+
