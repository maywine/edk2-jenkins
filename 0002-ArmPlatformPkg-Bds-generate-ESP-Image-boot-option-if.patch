From a1ad5bbe362469dbbd3e47263d055994b2d7ef4c Mon Sep 17 00:00:00 2001
From: Laszlo Ersek <lersek@redhat.com>
Date: Wed, 27 Nov 2013 01:07:05 +0100
Subject: [PATCH 2/9] ArmPlatformPkg/Bds: generate ESP Image boot option if
 user pref is unset

This hack is probably not upstreamable, but it should ease development:

If "PcdDefaultBootDevicePath" is set to the empty string in the platform
DSC file, then this patch will try to boot the file called "Image" from
the ESP. This should make the UEFI binary independent of the ESP's
characteristics (UUID of GPT partition, size, etc) and require disk image
files only to provide a file called "Image" in the ESP.

Contributed-under: TianoCore Contribution Agreement 1.0
Signed-off-by: Laszlo Ersek <lersek@redhat.com>
---
 ArmPlatformPkg/Bds/Bds.c   | 66 ++++++++++++++++++++++++++++++----------------
 ArmPlatformPkg/Bds/Bds.inf |  1 +
 2 files changed, 44 insertions(+), 23 deletions(-)

diff --git a/ArmPlatformPkg/Bds/Bds.c b/ArmPlatformPkg/Bds/Bds.c
index 3ee866c..803cd08 100644
--- a/ArmPlatformPkg/Bds/Bds.c
+++ b/ArmPlatformPkg/Bds/Bds.c
@@ -20,6 +20,7 @@
 #include <Protocol/Bds.h>
 
 #include <Guid/EventGroup.h>
+#include <Guid/Gpt.h>
 
 #define EFI_SET_TIMER_TO_SECOND   10000000
 
@@ -232,34 +233,53 @@ DefineDefaultBootEntries (
   Status = gRT->GetVariable (L"BootOrder", &gEfiGlobalVariableGuid, NULL, &Size, NULL);
   if (Status == EFI_NOT_FOUND) {
     if ((PcdGetPtr(PcdDefaultBootDevicePath) == NULL) || (StrLen ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath)) == 0)) {
-      return EFI_UNSUPPORTED;
-    }
+      UINTN      NrHandles;
+      EFI_HANDLE *Handles;
 
-    Status = gBS->LocateProtocol (&gEfiDevicePathFromTextProtocolGuid, NULL, (VOID **)&EfiDevicePathFromTextProtocol);
-    if (EFI_ERROR(Status)) {
-      // You must provide an implementation of DevicePathFromTextProtocol in your firmware (eg: DevicePathDxe)
-      DEBUG((EFI_D_ERROR,"Error: Bds requires DevicePathFromTextProtocol\n"));
-      return Status;
-    }
-    BootDevicePath = EfiDevicePathFromTextProtocol->ConvertTextToDevicePath ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath));
+      BdsConnectAllDrivers();
+      Status = gBS->LocateHandleBuffer (ByProtocol,
+                      &gEfiPartTypeSystemPartGuid, NULL /* SearchKey */,
+                      &NrHandles, &Handles);
+      if (!EFI_ERROR (Status)) {
+        ASSERT (NrHandles > 0);
+        BootDevicePath = FileDevicePath (Handles[0], L"Image");
+        if (BootDevicePath == NULL) {
+          Status = EFI_OUT_OF_RESOURCES;
+        }
+        FreePool (Handles);
+      }
+      if (EFI_ERROR (Status)) {
+        DEBUG ((EFI_D_ERROR, "failed to auto-create default boot option: %r\n",
+          Status));
+        return Status;
+      }
+    } else {
+      Status = gBS->LocateProtocol (&gEfiDevicePathFromTextProtocolGuid, NULL, (VOID **)&EfiDevicePathFromTextProtocol);
+      if (EFI_ERROR(Status)) {
+        // You must provide an implementation of DevicePathFromTextProtocol in your firmware (eg: DevicePathDxe)
+        DEBUG((EFI_D_ERROR,"Error: Bds requires DevicePathFromTextProtocol\n"));
+        return Status;
+      }
+      BootDevicePath = EfiDevicePathFromTextProtocol->ConvertTextToDevicePath ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath));
 
-    DEBUG_CODE_BEGIN();
-      // We convert back to the text representation of the device Path to see if the initial text is correct
-      EFI_DEVICE_PATH_TO_TEXT_PROTOCOL* DevicePathToTextProtocol;
-      CHAR16* DevicePathTxt;
+      DEBUG_CODE_BEGIN();
+        // We convert back to the text representation of the device Path to see if the initial text is correct
+        EFI_DEVICE_PATH_TO_TEXT_PROTOCOL* DevicePathToTextProtocol;
+        CHAR16* DevicePathTxt;
 
-      Status = gBS->LocateProtocol(&gEfiDevicePathToTextProtocolGuid, NULL, (VOID **)&DevicePathToTextProtocol);
-      ASSERT_EFI_ERROR(Status);
-      DevicePathTxt = DevicePathToTextProtocol->ConvertDevicePathToText (BootDevicePath, TRUE, TRUE);
+        Status = gBS->LocateProtocol(&gEfiDevicePathToTextProtocolGuid, NULL, (VOID **)&DevicePathToTextProtocol);
+        ASSERT_EFI_ERROR(Status);
+        DevicePathTxt = DevicePathToTextProtocol->ConvertDevicePathToText (BootDevicePath, TRUE, TRUE);
 
-      if (StrCmp ((CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt) != 0) {
-        DEBUG ((EFI_D_ERROR, "Device Path given: '%s' Device Path expected: '%s'\n",
-            (CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt));
-        ASSERT_EFI_ERROR (EFI_INVALID_PARAMETER);
-      }
+        if (StrCmp ((CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt) != 0) {
+          DEBUG ((EFI_D_ERROR, "Device Path given: '%s' Device Path expected: '%s'\n",
+              (CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt));
+          ASSERT_EFI_ERROR (EFI_INVALID_PARAMETER);
+        }
 
-      FreePool (DevicePathTxt);
-    DEBUG_CODE_END();
+        FreePool (DevicePathTxt);
+      DEBUG_CODE_END();
+    }
 
     // Create the entry is the Default values are correct
     if (BootDevicePath != NULL) {
diff --git a/ArmPlatformPkg/Bds/Bds.inf b/ArmPlatformPkg/Bds/Bds.inf
index 06e8d91..442bf2f 100644
--- a/ArmPlatformPkg/Bds/Bds.inf
+++ b/ArmPlatformPkg/Bds/Bds.inf
@@ -60,6 +60,7 @@
   gEfiFileSystemInfoGuid
   gArmGlobalVariableGuid
   gFdtVariableGuid
+  gEfiPartTypeSystemPartGuid
 
 [Protocols]
   gEfiBdsArchProtocolGuid
-- 
1.8.3.1

