From 0ce6ae398c6aace0a1331330eb07d9092d03a2f9 Mon Sep 17 00:00:00 2001
From: Laszlo Ersek <lersek@redhat.com>
Date: Wed, 27 Nov 2013 01:07:05 +0100
Subject: [PATCH 2/9] ArmPlatformPkg/Bds: generate ESP Image boot option if
 user pref is unset

This hack is probably not upstreamable, but it should ease development:

If "PcdDefaultBootDevicePath" is set to the empty string in the platform
DSC file, then this patch will try to boot the file called "Image" from
the ESP. This should make the UEFI binary independent of the ESP's
characteristics (UUID of GPT partition, size, etc) and require disk image
files only to provide a file called "Image" in the ESP.

Contributed-under: TianoCore Contribution Agreement 1.0
Signed-off-by: Laszlo Ersek <lersek@redhat.com>
---
 ArmPlatformPkg/Bds/Bds.c   | 66 ++++++++++++++++++++++++++++++----------------
 ArmPlatformPkg/Bds/Bds.inf |  1 +
 2 files changed, 44 insertions(+), 23 deletions(-)

diff --git a/ArmPlatformPkg/Bds/Bds.c b/ArmPlatformPkg/Bds/Bds.c
index 1fab439..dd391b1 100644
--- a/ArmPlatformPkg/Bds/Bds.c
+++ b/ArmPlatformPkg/Bds/Bds.c
@@ -20,6 +20,7 @@
 #include <Protocol/Bds.h>
 
 #include <Guid/EventGroup.h>
+#include <Guid/Gpt.h>
 
 #define EFI_SET_TIMER_TO_SECOND   10000000
 
@@ -238,34 +239,53 @@ DefineDefaultBootEntries (
   Status = gRT->GetVariable (L"BootOrder", &gEfiGlobalVariableGuid, NULL, &Size, NULL);
   if (Status == EFI_NOT_FOUND) {
     if ((PcdGetPtr(PcdDefaultBootDevicePath) == NULL) || (StrLen ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath)) == 0)) {
-      return EFI_UNSUPPORTED;
-    }
+      UINTN      NrHandles;
+      EFI_HANDLE *Handles;
 
-    Status = gBS->LocateProtocol (&gEfiDevicePathFromTextProtocolGuid, NULL, (VOID **)&EfiDevicePathFromTextProtocol);
-    if (EFI_ERROR(Status)) {
-      // You must provide an implementation of DevicePathFromTextProtocol in your firmware (eg: DevicePathDxe)
-      DEBUG((EFI_D_ERROR,"Error: Bds requires DevicePathFromTextProtocol\n"));
-      return Status;
-    }
-    BootDevicePath = EfiDevicePathFromTextProtocol->ConvertTextToDevicePath ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath));
+      BdsConnectAllDrivers();
+      Status = gBS->LocateHandleBuffer (ByProtocol,
+                      &gEfiPartTypeSystemPartGuid, NULL /* SearchKey */,
+                      &NrHandles, &Handles);
+      if (!EFI_ERROR (Status)) {
+        ASSERT (NrHandles > 0);
+        BootDevicePath = FileDevicePath (Handles[0], L"Image");
+        if (BootDevicePath == NULL) {
+          Status = EFI_OUT_OF_RESOURCES;
+        }
+        FreePool (Handles);
+      }
+      if (EFI_ERROR (Status)) {
+        DEBUG ((EFI_D_ERROR, "failed to auto-create default boot option: %r\n",
+          Status));
+        return Status;
+      }
+    } else {
+      Status = gBS->LocateProtocol (&gEfiDevicePathFromTextProtocolGuid, NULL, (VOID **)&EfiDevicePathFromTextProtocol);
+      if (EFI_ERROR(Status)) {
+        // You must provide an implementation of DevicePathFromTextProtocol in your firmware (eg: DevicePathDxe)
+        DEBUG((EFI_D_ERROR,"Error: Bds requires DevicePathFromTextProtocol\n"));
+        return Status;
+      }
+      BootDevicePath = EfiDevicePathFromTextProtocol->ConvertTextToDevicePath ((CHAR16*)PcdGetPtr(PcdDefaultBootDevicePath));
 
-    DEBUG_CODE_BEGIN();
-      // We convert back to the text representation of the device Path to see if the initial text is correct
-      EFI_DEVICE_PATH_TO_TEXT_PROTOCOL* DevicePathToTextProtocol;
-      CHAR16* DevicePathTxt;
+      DEBUG_CODE_BEGIN();
+        // We convert back to the text representation of the device Path to see if the initial text is correct
+        EFI_DEVICE_PATH_TO_TEXT_PROTOCOL* DevicePathToTextProtocol;
+        CHAR16* DevicePathTxt;
 
-      Status = gBS->LocateProtocol(&gEfiDevicePathToTextProtocolGuid, NULL, (VOID **)&DevicePathToTextProtocol);
-      ASSERT_EFI_ERROR(Status);
-      DevicePathTxt = DevicePathToTextProtocol->ConvertDevicePathToText (BootDevicePath, TRUE, TRUE);
+        Status = gBS->LocateProtocol(&gEfiDevicePathToTextProtocolGuid, NULL, (VOID **)&DevicePathToTextProtocol);
+        ASSERT_EFI_ERROR(Status);
+        DevicePathTxt = DevicePathToTextProtocol->ConvertDevicePathToText (BootDevicePath, TRUE, TRUE);
 
-      if (StrCmp ((CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt) != 0) {
-        DEBUG ((EFI_D_ERROR, "Device Path given: '%s' Device Path expected: '%s'\n",
-            (CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt));
-        ASSERT_EFI_ERROR (EFI_INVALID_PARAMETER);
-      }
+        if (StrCmp ((CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt) != 0) {
+          DEBUG ((EFI_D_ERROR, "Device Path given: '%s' Device Path expected: '%s'\n",
+              (CHAR16*)PcdGetPtr (PcdDefaultBootDevicePath), DevicePathTxt));
+          ASSERT_EFI_ERROR (EFI_INVALID_PARAMETER);
+        }
 
-      FreePool (DevicePathTxt);
-    DEBUG_CODE_END();
+        FreePool (DevicePathTxt);
+      DEBUG_CODE_END();
+    }
 
     // Create the entry is the Default values are correct
     if (BootDevicePath != NULL) {
diff --git a/ArmPlatformPkg/Bds/Bds.inf b/ArmPlatformPkg/Bds/Bds.inf
index e04c86d..ad10045 100644
--- a/ArmPlatformPkg/Bds/Bds.inf
+++ b/ArmPlatformPkg/Bds/Bds.inf
@@ -53,6 +53,7 @@
   gEfiEndOfDxeEventGroupGuid
   gEfiFileSystemInfoGuid
   gArmGlobalVariableGuid
+  gEfiPartTypeSystemPartGuid
 
 [Protocols]
   gEfiBdsArchProtocolGuid
-- 
1.8.3.1

